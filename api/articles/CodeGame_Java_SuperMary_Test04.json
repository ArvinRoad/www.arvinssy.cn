{"title":"Java 超级玛丽背景类","uid":"bfaf101dcab4b3312323018980f23fb2","slug":"CodeGame_Java_SuperMary_Test04","date":"2021-11-07T12:13:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Java_SuperMary_Test04.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.572b4ab9d87462765ef358a9e15819ce?rik=db7288wWpYy4zA&riu=http%3a%2f%2fwww.3dmgame.com%2fuploads%2fallimg%2f160908%2f226_160908015610_1.jpg&ehk=DXhBtkC4y5FgVe%2blsbCvr%2f8wv7AUQFSZwlLPj6DmerM%3d&risl=&pid=ImgRaw&r=0","content":"<p>配合文件：<a href=\"https://arvinroad.github.io/2021/11/07/CodeGame_Java_SuperMary_Test03/\">Java 超级玛丽窗口</a></p>\n<hr>\n<h4 id=\"代码演示：\"><a href=\"#代码演示：\" class=\"headerlink\" title=\"代码演示：\"></a>代码演示：</h4><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">package com.arvin;\n\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.List;\n\n&#x2F;**\n *  背景类\n *&#x2F;\n\npublic class BackGround &#123;\n\n    &#x2F;* 调用BufferedImage 该对象用于显示当前场景的图片 *&#x2F;\n    private BufferedImage bgImage &#x3D; null;\n\n    &#x2F;* 记录当前是第几个场景(关卡) *&#x2F;\n    private int sort;\n\n    &#x2F;* 判断是否是最后一个场景 *&#x2F;\n    private boolean flag;\n\n    &#x2F;* 用于存放我们所有的障碍物 *&#x2F;\n    private List&lt;Obstacle&gt; ObstacleList &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;* 用于存放我们所有的敌人 *&#x2F;\n    private List&lt;Enemy&gt; enemyList &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;* 用于显示旗杆 *&#x2F;\n    private BufferedImage Gan &#x3D; null;\n\n    &#x2F;* 用于显示城堡 *&#x2F;\n    private BufferedImage Tower &#x3D; null;\n\n    &#x2F;&#x2F; 判断马里奥是否到达旗杆位置\n    private boolean isReach &#x3D; false;\n\n    &#x2F;&#x2F; 判断旗子是否落地\n    private boolean isBase &#x3D; false;\n\n    &#x2F;* 空参构造 *&#x2F;\n    public BackGround() &#123;\n\n    &#125;\n\n    &#x2F;* 含两个参数的构造参数 *&#x2F;\n    public BackGround(int sort,boolean flag) &#123;\n        this.sort &#x3D; sort;\n        this.flag &#x3D; flag;\n\n        &#x2F;* 判断我们此时的 flag 是否为 true *&#x2F;\n        if (flag) &#123;\n            bgImage &#x3D; StaticValue.BackgroundImage_Two;\n        &#125;else&#123;\n            bgImage &#x3D; StaticValue.BackgroundImage_Noe;\n        &#125;\n\n        &#x2F;* 判断是否是第一关 *&#x2F;\n        if (sort &#x3D;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 绘制第一关的地面，上地面 type &#x3D; 1，下地面 type &#x3D; 2\n            for (int i &#x3D; 0; i &lt; 27; i++) &#123;\n                ObstacleList.add(new Obstacle(i*30,420,1,this));    &#x2F;&#x2F; 绘制上地面\n            &#125;\n            &#x2F;&#x2F; 双重 For 循环绘制下地面\n            for (int j &#x3D; 0; j &lt;&#x3D; 120; j +&#x3D; 30) &#123;\n                for (int i &#x3D; 0; i &lt; 27; i++) &#123;\n                    ObstacleList.add(new Obstacle(i*30,570-j,2,this));\n                &#125;\n            &#125;\n\n\n            &#x2F;* 绘制砖块A *&#x2F;\n            for (int i &#x3D; 120; i &lt;&#x3D; 150 ; i +&#x3D; 30) &#123;\n                ObstacleList.add(new Obstacle(i,300,3,this));\n            &#125;\n            &#x2F;&#x2F; 绘制砖块 B - F\n            for (int i &#x3D; 300; i &lt;&#x3D; 570; i +&#x3D; 30) &#123;\n                if (i &#x3D;&#x3D; 360 || i &#x3D;&#x3D; 390 || i &#x3D;&#x3D; 480 || i&#x3D;&#x3D;510 || i &#x3D;&#x3D; 540) &#123;   &#x2F;&#x2F; 判断是否是蓝色砖块\n                    ObstacleList.add(new Obstacle(i,300,3,this));\n                &#125;else&#123;  &#x2F;&#x2F; 否则是普通砖块\n                    ObstacleList.add(new Obstacle(i,300,0,this));\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 绘制砖块 G\n            for (int i &#x3D; 420; i &lt;&#x3D; 450; i+&#x3D;30) &#123;\n                ObstacleList.add(new Obstacle(i,240,3,this));\n            &#125;\n\n            &#x2F;&#x2F; 绘制水管\n            for (int i &#x3D; 360; i &lt;&#x3D;600; i +&#x3D; 25)&#123;\n                if (i &#x3D;&#x3D; 360)&#123; &#x2F;&#x2F; 绘制水管最上层\n                    ObstacleList.add(new Obstacle(620,i,5,this));\n                    ObstacleList.add(new Obstacle(645,i,6,this));\n                &#125;else&#123;\n                    ObstacleList.add(new Obstacle(620,i,7,this));\n                    ObstacleList.add(new Obstacle(645,i,8,this));\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 绘制第一关蘑菇敌人\n            enemyList.add(new Enemy(580,385,true,1,this));\n            &#x2F;&#x2F; 绘制第一关食人花敌人\n            enemyList.add(new Enemy(635,420,true,2,328,428,this));\n        &#125;\n\n        &#x2F;&#x2F; 判断是否是第二关\n        if (sort &#x3D;&#x3D; 2) &#123;\n            &#x2F;&#x2F; 绘制第二关地面\n            for (int i &#x3D; 0; i &lt; 27; i++)&#123;\n                ObstacleList.add(new Obstacle(i*30,420,1,this));\n            &#125;\n            for (int j &#x3D; 0; j &lt;&#x3D; 120; j+&#x3D; 30)&#123;\n                for (int i &#x3D; 0; i &lt; 27; i++)&#123;\n                    ObstacleList.add(new Obstacle(i*30,570-j,2,this));\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 绘制水管和第一关一样只需要修改坐标\n            for (int i &#x3D;  360; i &lt;&#x3D; 600; i +&#x3D; 25)&#123;\n                if (i &#x3D;&#x3D; 360) &#123;\n                    ObstacleList.add(new Obstacle(60,i,5,this));\n                    ObstacleList.add(new Obstacle(85,i,6,this));\n                &#125;else&#123;\n                    ObstacleList.add(new Obstacle(60,i,7,this));\n                    ObstacleList.add(new Obstacle(85,i,8,this));\n                &#125;\n            &#125;\n\n            for (int i &#x3D; 330; i &lt;&#x3D;600; i+&#x3D; 25)&#123;\n                if (i &#x3D;&#x3D; 330) &#123;\n                    ObstacleList.add(new Obstacle(620,i,5,this));\n                    ObstacleList.add(new Obstacle(645,i,6,this));\n                &#125;else&#123;\n                    ObstacleList.add(new Obstacle(620,i,7,this));\n                    ObstacleList.add(new Obstacle(645,i,8,this));\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 绘制砖块 C\n            ObstacleList.add(new Obstacle(300,330,0,this));\n\n            &#x2F;&#x2F; 绘制砖块 B E G\n            for (int i &#x3D; 270; i &lt;&#x3D; 330; i+&#x3D;30)&#123;\n                if (i &#x3D;&#x3D; 270 || i &#x3D;&#x3D; 330) &#123;\n                    ObstacleList.add(new Obstacle(i,360,0,this));\n                &#125;else&#123;\n                    ObstacleList.add(new Obstacle(i,360,3,this));\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 绘制砖块 A D F H I\n            for (int i &#x3D; 240; i &lt;&#x3D; 360; i +&#x3D; 30)&#123;\n                if (i &#x3D;&#x3D; 240 || i &#x3D;&#x3D; 360)&#123;\n                    ObstacleList.add(new Obstacle(i,390,0,this));\n                &#125;else&#123;\n                    ObstacleList.add(new Obstacle(i,390,3,this));\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 绘制妨碍 1 砖块\n            ObstacleList.add(new Obstacle(240,300,0,this));\n\n            &#x2F;&#x2F; 绘制 空 1 - 4 砖块\n            for (int i &#x3D; 360; i &lt;&#x3D; 540; i +&#x3D; 60) &#123;\n                ObstacleList.add(new Obstacle(i,270,3,this));\n            &#125;\n\n            &#x2F;&#x2F; 绘制第二关第一个食人花敌人\n            enemyList.add(new Enemy(75,420,true,2,328,418,this));\n            &#x2F;&#x2F; 绘制第二关第二个食人花敌人\n            enemyList.add(new Enemy(635,420,true,2,298,388,this));\n            &#x2F;&#x2F; 绘制第二关第一个蘑菇敌人\n            enemyList.add(new Enemy(200,385,true,1,this));\n            &#x2F;&#x2F; 绘制第二关第二个蘑菇敌人\n            enemyList.add(new Enemy(500,385,true,1,this));\n        &#125;\n\n        &#x2F;&#x2F; 判断是否是第三关\n        if (sort &#x3D;&#x3D; 3) &#123;\n            &#x2F;&#x2F; 绘制第三关地面\n            for (int i &#x3D; 0; i &lt; 27; i++)&#123;\n                ObstacleList.add(new Obstacle(i*30,420,1,this));\n            &#125;\n            for (int j &#x3D; 0; j &lt;&#x3D; 120; j+&#x3D; 30)&#123;\n                for (int i &#x3D; 0; i &lt; 27; i++)&#123;\n                    ObstacleList.add(new Obstacle(i*30,570-j,2,this));\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 绘制 A - O 砖块\n            int temp &#x3D; 290;\n            for (int i &#x3D; 390; i &gt;&#x3D; 270; i -&#x3D; 30) &#123;\n                for (int j &#x3D; temp; j &lt;&#x3D; 410; j +&#x3D; 30) &#123;\n                    ObstacleList.add(new Obstacle(j,i,3,this));\n                &#125;\n                temp +&#x3D; 30;\n            &#125;\n\n            &#x2F;&#x2F; 绘制 P - R 砖块\n            temp &#x3D; 60;\n            for (int i &#x3D; 390; i &gt;&#x3D; 360; i -&#x3D; 30) &#123;\n                for (int j &#x3D; temp; j &lt;&#x3D; 90; j +&#x3D; 30) &#123;\n                    ObstacleList.add(new Obstacle(j,i,3,this));\n                &#125;\n                temp +&#x3D; 30;\n            &#125;\n\n            &#x2F;&#x2F; 绘制旗杆\n            Gan &#x3D; StaticValue.Gan;\n\n            &#x2F;&#x2F;绘制城堡\n            Tower &#x3D; StaticValue.Tower;\n\n            &#x2F;&#x2F; 添加旗子到旗杆上 旗子的坐标 x515 y220\n            ObstacleList.add(new Obstacle(515,220,4,this));\n\n            &#x2F;&#x2F; 绘制第三关蘑菇敌人\n            enemyList.add(new Enemy(150,385,true,1,this));\n        &#125;\n    &#125;\n\n    &#x2F;* 生成上面函数的 Get 方法 *&#x2F;\n\n    public BufferedImage getBgImage() &#123;\n        return bgImage;\n    &#125;\n\n    public int getSort() &#123;\n        return sort;\n    &#125;\n\n    public boolean isFlag() &#123;\n        return flag;\n    &#125;\n\n    &#x2F;&#x2F; 生成 ObstacleList 的 Get 方法\n    public List&lt;Obstacle&gt; getObstacleList() &#123;\n        return ObstacleList;\n    &#125;\n\n    &#x2F;&#x2F; 生成 城堡和旗杆的 Get 方法\n    public BufferedImage getGan() &#123;\n        return Gan;\n    &#125;\n\n    public BufferedImage getTower() &#123;\n        return Tower;\n    &#125;\n\n    &#x2F;&#x2F; 生成 判断是否到达旗杆位置的 Set Get 方法\n    public boolean isReach() &#123;\n        return isReach;\n    &#125;\n\n    public void setReach(boolean reach) &#123;\n        isReach &#x3D; reach;\n    &#125;\n\n    &#x2F;&#x2F; 生成 判断旗子是否落地 Set Get 方法\n\n    public boolean isBase() &#123;\n        return isBase;\n    &#125;\n\n    public void setBase(boolean base) &#123;\n        isBase &#x3D; base;\n    &#125;\n\n    &#x2F;&#x2F; 用于存放我们所有的敌人 的 Get 方法\n    public List&lt;Enemy&gt; getEnemyList() &#123;\n        return enemyList;\n    &#125;\n&#125;</code></pre>","text":"配合文件：Java 超级玛丽窗口 代码演示：package com.arvin; import java.awt.image.BufferedImage; im...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A\"><span class=\"toc-text\">代码演示：</span></a></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java 超级玛丽窗口","uid":"3c2d266b9caeb01b9460324e5828e520","slug":"CodeGame_Java_SuperMary_Test03","date":"2021-11-07T12:16:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Java_SuperMary_Test03.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/OIP-C.AEFItfuco5DjCukU9F-f-wFOC6?pid=ImgDet&rs=1","text":"说明首先要基于：Java 创建窗口 其次基于：Java 超级玛丽常量类 搭配文件：Java 超级玛丽背景类 代码演示package com.arvin; imp...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Minecraft 类游戏地形生成算法","uid":"b9f0a691f1e575c41aa38be21dfe4644","slug":"CodeGame_Technology_Minecratf_Terrain01","date":"2021-11-06T21:11:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Technology_Minecratf_Terrain01.json","keywords":null,"cover":"https://z3.ax1x.com/2021/11/07/IlDnN6.png","text":"Minecraft 类游戏地形生成算法噪声算法 为什么要有噪声？ 随机数 VS 噪声 随机数：随机生成一个噪点不一的黑白图，但因为过于随机生成的图看起来特别不舒...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}