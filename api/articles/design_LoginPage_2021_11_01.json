{"title":"Login Page 设计演示01","uid":"6fcc820b9ac2c2a3332c50f6a1ac1644","slug":"design_LoginPage_2021_11_01","date":"2021-10-31T17:33:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/design_LoginPage_2021_11_01.json","keywords":null,"cover":"https://z3.ax1x.com/2021/11/01/IpzNu9.jpg","content":"<p><strong>分享大家一个好看的 Login Page 代码</strong></p>\n<hr>\n<h3 id=\"演示图\"><a href=\"#演示图\" class=\"headerlink\" title=\"演示图\"></a>演示图</h3><p><img src=\"https://z3.ax1x.com/2021/11/01/IpzNu9.jpg\"><br><img src=\"https://z3.ax1x.com/2021/11/01/IpzUBR.jpg\"></p>\n<h3 id=\"演示代码\"><a href=\"#演示代码\" class=\"headerlink\" title=\"演示代码\"></a>演示代码</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--\n    Developer: @Arvin\n    Explain: Login Page\n--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&#x2F;&gt;\n    &lt;title&gt;Login Page&lt;&#x2F;title&gt;\n    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;\n        body&#123;\n            background-color: #A7CFFF;\n            text-align: center;\n            overflow: hidden;\n            margin: 0;\n        &#125;\n\n        H1&#123;\n            margin-top: 38px;\n        &#125;\n\n        H1,H2&#123;\n            color: #1F2029;\n            user-select: none;\n        &#125;\n\n        .switch&#123;\n            background-color: #FCFBFA;\n            width: 400px;\n            height: 170px;\n            position: absolute;\n            left: 50%;\n            margin-left: -200px;\n            top: 73%;\n            border-radius: 8px;\n        &#125;\n\n        &#x2F;* 选择同级后最近元素 @Arvin *&#x2F;\n        #change:checked+label,\n        #change:not(:checked)+label&#123;\n            background-color: #ff5f99;\n            color: #FCFBFA;\n            width: 280px;\n            position: absolute;\n            padding: 8px 0; &#x2F;* Padding 方便文字垂直居中显示 @Arvin *&#x2F;\n            left: 50%;\n            font-size: 24px;\n            font-weight: 600;\n            margin-left: -140px;\n            top: 82%;\n            border-radius: 25px;\n            cursor: pointer;\n        &#125;\n\n        &#x2F;* 页面旋转模块 *&#x2F;\n        .turn&#123;\n            width: 400px;\n            height: 450px;\n            top: 8%;\n            position: absolute;\n            perspective: 800px; &#x2F;* 旋转时候的透视效果 @Arvin *&#x2F;\n            left: 50%;\n            margin-left: -200px;\n        &#125;\n\n        .over&#123;\n            width: 100%;\n            height: 100%;\n            transition: all 1.6s ease; &#x2F;* 旋转的持续时间 ease 是慢快慢 @Arvin *&#x2F;\n            transform-style: preserve-3d;\n        &#125;\n\n        #change:checked\n        ~\n        .turn .over&#123;\n            transform: rotateY(180deg);\n        &#125;\n\n        form&#123;\n            position: absolute;\n            height: 100%;\n            border-radius: 25px;\n            background-color: #FCFBFA;\n            transform-style: preserve-3d;\n        &#125;\n\n        .sign&#123;\n            transform: rotateY(180deg);\n        &#125;\n\n        input&#123;\n            background-color: #4E495D;\n            width: 70%;\n            height: 48px;\n            border-radius: 8px;\n            padding: 0 16px;\n            margin-bottom: 20px;\n            font-size: 18px;\n            font-weight: 500;\n            color: #ff5f99;\n            outline: none;\n            border: none;\n            box-shadow: 0 4px 8px rgba(78, 73, 79, .5);\n            transform-style: preserve-3d;\n            transform: translate3d(0, 0, 1px);\n        &#125;\n\n        &#x2F;* 选择 Class 为 Login 的子元素中的前三个 input @Arvin *&#x2F;\n        .login input:nth-child(-n+3)&#123;\n            margin: 20px 0;\n        &#125;\n\n        .btn&#123;\n            background-color: #981E61;\n            border: none;\n            width: 280px;\n            font-weight: 600;\n            color: #FCFBFA;\n            font-size: 24px;\n            padding: 6px 0;\n            border-radius: 25px;\n            margin-top: 15px;\n            cursor: pointer;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n\n&lt;!-- 旋转开关 @Arvin --&gt;\n&lt;div class&#x3D;&quot;switch&quot;&gt;&lt;H2&gt;没有&#x2F;已有账户？&lt;&#x2F;H2&gt;&lt;&#x2F;div&gt;\n&lt;input type&#x3D;&quot;checkbox&quot; style&#x3D;&quot;display: none;&quot; id&#x3D;&quot;change&quot;&#x2F;&gt;\n&lt;label for&#x3D;&quot;change&quot;&gt;切 换&lt;&#x2F;label&gt;\n\n&lt;div class&#x3D;&quot;turn&quot;&gt;\n    &lt;div class&#x3D;&quot;over&quot;&gt;\n        &lt;form action&#x3D;&quot;&quot; class&#x3D;&quot;login&quot;&gt;\n            &lt;H1&gt;欢迎回来（＾－＾）&lt;&#x2F;H1&gt;\n            &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;用户名&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;passwirld&quot; placeholder&#x3D;&quot;密码&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn&quot; value&#x3D;&quot;登 录&quot;&#x2F;&gt;\n        &lt;&#x2F;form&gt;\n\n        &lt;form action&#x3D;&quot;&quot; class&#x3D;&quot;sign&quot;&gt;\n            &lt;H1&gt;加入我们（＾－＾）&lt;&#x2F;H1&gt;\n            &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;用户名&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;邮箱&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;passwirld&quot; placeholder&#x3D;&quot;密码&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;passwirld&quot; placeholder&#x3D;&quot;确认密码&quot;&#x2F;&gt;\n            &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt;\n        &lt;&#x2F;form&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n&lt;!-- 樱花效果 来源于网上开源代码 @Arvin --&gt;\n&lt;!-- partial:index.partial.html --&gt;\n&lt;canvas id&#x3D;&quot;sakura&quot;&gt;&lt;&#x2F;canvas&gt;\n\n&lt;!-- sakura shader --&gt;\n&lt;script id&#x3D;&quot;sakura_point_vsh&quot; type&#x3D;&quot;x-shader&#x2F;x_vertex&quot;&gt;\n  uniform mat4 uProjection;\n  uniform mat4 uModelview;\n  uniform vec3 uResolution;\n  uniform vec3 uOffset;\n  uniform vec3 uDOF;  &#x2F;&#x2F;x:focus distance, y:focus radius, z:max radius\n  uniform vec3 uFade; &#x2F;&#x2F;x:start distance, y:half distance, z:near fade start\n\n  attribute vec3 aPosition;\n  attribute vec3 aEuler;\n  attribute vec2 aMisc; &#x2F;&#x2F;x:size, y:fade\n\n  varying vec3 pposition;\n  varying float psize;\n  varying float palpha;\n  varying float pdist;\n\n  &#x2F;&#x2F;varying mat3 rotMat;\n  varying vec3 normX;\n  varying vec3 normY;\n  varying vec3 normZ;\n  varying vec3 normal;\n\n  varying float diffuse;\n  varying float specular;\n  varying float rstop;\n  varying float distancefade;\n\n  void main(void) &#123;\n      &#x2F;&#x2F; Projection is based on vertical angle\n      vec4 pos &#x3D; uModelview * vec4(aPosition + uOffset, 1.0);\n      gl_Position &#x3D; uProjection * pos;\n      gl_PointSize &#x3D; aMisc.x * uProjection[1][1] &#x2F; -pos.z * uResolution.y * 0.5;\n\n      pposition &#x3D; pos.xyz;\n      psize &#x3D; aMisc.x;\n      pdist &#x3D; length(pos.xyz);\n      palpha &#x3D; smoothstep(0.0, 1.0, (pdist - 0.1) &#x2F; uFade.z);\n\n      vec3 elrsn &#x3D; sin(aEuler);\n      vec3 elrcs &#x3D; cos(aEuler);\n      mat3 rotx &#x3D; mat3(\n          1.0, 0.0, 0.0,\n          0.0, elrcs.x, elrsn.x,\n          0.0, -elrsn.x, elrcs.x\n      );\n      mat3 roty &#x3D; mat3(\n          elrcs.y, 0.0, -elrsn.y,\n          0.0, 1.0, 0.0,\n          elrsn.y, 0.0, elrcs.y\n      );\n      mat3 rotz &#x3D; mat3(\n          elrcs.z, elrsn.z, 0.0,\n          -elrsn.z, elrcs.z, 0.0,\n          0.0, 0.0, 1.0\n      );\n      mat3 rotmat &#x3D; rotx * roty * rotz;\n      normal &#x3D; rotmat[2];\n\n      mat3 trrotm &#x3D; mat3(\n          rotmat[0][0], rotmat[1][0], rotmat[2][0],\n          rotmat[0][1], rotmat[1][1], rotmat[2][1],\n          rotmat[0][2], rotmat[1][2], rotmat[2][2]\n      );\n      normX &#x3D; trrotm[0];\n      normY &#x3D; trrotm[1];\n      normZ &#x3D; trrotm[2];\n\n      const vec3 lit &#x3D; vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);\n\n      float tmpdfs &#x3D; dot(lit, normal);\n      if(tmpdfs &lt; 0.0) &#123;\n          normal &#x3D; -normal;\n          tmpdfs &#x3D; dot(lit, normal);\n      &#125;\n      diffuse &#x3D; 0.4 + tmpdfs;\n\n      vec3 eyev &#x3D; normalize(-pos.xyz);\n      if(dot(eyev, normal) &gt; 0.0) &#123;\n          vec3 hv &#x3D; normalize(eyev + lit);\n          specular &#x3D; pow(max(dot(hv, normal), 0.0), 20.0);\n      &#125;\n      else &#123;\n          specular &#x3D; 0.0;\n      &#125;\n\n      rstop &#x3D; clamp((abs(pdist - uDOF.x) - uDOF.y) &#x2F; uDOF.z, 0.0, 1.0);\n      rstop &#x3D; pow(rstop, 0.5);\n      &#x2F;&#x2F;-0.69315 &#x3D; ln(0.5)\n      distancefade &#x3D; min(1.0, exp((uFade.x - pdist) * 0.69315 &#x2F; uFade.y));\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;script id&#x3D;&quot;sakura_point_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n\n  uniform vec3 uDOF;  &#x2F;&#x2F;x:focus distance, y:focus radius, z:max radius\n  uniform vec3 uFade; &#x2F;&#x2F;x:start distance, y:half distance, z:near fade start\n\n  const vec3 fadeCol &#x3D; vec3(0.08, 0.03, 0.06);\n\n  varying vec3 pposition;\n  varying float psize;\n  varying float palpha;\n  varying float pdist;\n\n  &#x2F;&#x2F;varying mat3 rotMat;\n  varying vec3 normX;\n  varying vec3 normY;\n  varying vec3 normZ;\n  varying vec3 normal;\n\n  varying float diffuse;\n  varying float specular;\n  varying float rstop;\n  varying float distancefade;\n\n  float ellipse(vec2 p, vec2 o, vec2 r) &#123;\n      vec2 lp &#x3D; (p - o) &#x2F; r;\n      return length(lp) - 1.0;\n  &#125;\n\n  void main(void) &#123;\n      vec3 p &#x3D; vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;\n      vec3 d &#x3D; vec3(0.0, 0.0, -1.0);\n      float nd &#x3D; normZ.z; &#x2F;&#x2F;dot(-normZ, d);\n      if(abs(nd) &lt; 0.0001) discard;\n\n      float np &#x3D; dot(normZ, p);\n      vec3 tp &#x3D; p + d * np &#x2F; nd;\n      vec2 coord &#x3D; vec2(dot(normX, tp), dot(normY, tp));\n\n      &#x2F;&#x2F;angle &#x3D; 15 degree\n      const float flwrsn &#x3D; 0.258819045102521;\n      const float flwrcs &#x3D; 0.965925826289068;\n      mat2 flwrm &#x3D; mat2(flwrcs, -flwrsn, flwrsn, flwrcs);\n      vec2 flwrp &#x3D; vec2(abs(coord.x), coord.y) * flwrm;\n\n      float r;\n      if(flwrp.x &lt; 0.0) &#123;\n          r &#x3D; ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);\n      &#125;\n      else &#123;\n          r &#x3D; ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);\n      &#125;\n\n      if(r &gt; rstop) discard;\n\n      vec3 col &#x3D; mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);\n      float grady &#x3D; mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));\n      col *&#x3D; vec3(1.0, grady, grady);\n      col *&#x3D; mix(0.8, 1.0, pow(abs(coord.x), 0.3));\n      col &#x3D; col * diffuse + specular;\n\n      col &#x3D; mix(fadeCol, col, distancefade);\n\n      float alpha &#x3D; (rstop &gt; 0.001)? (0.5 - r &#x2F; (rstop * 2.0)) : 1.0;\n      alpha &#x3D; smoothstep(0.0, 1.0, alpha) * palpha;\n\n      gl_FragColor &#x3D; vec4(col * 0.5, alpha);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;!-- effects --&gt;\n&lt;script id&#x3D;&quot;fx_common_vsh&quot; type&#x3D;&quot;x-shader&#x2F;x_vertex&quot;&gt;\n  uniform vec3 uResolution;\n  attribute vec2 aPosition;\n\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n\n  void main(void) &#123;\n      gl_Position &#x3D; vec4(aPosition, 0.0, 1.0);\n      texCoord &#x3D; aPosition.xy * 0.5 + vec2(0.5, 0.5);\n      screenCoord &#x3D; aPosition.xy * vec2(uResolution.z, 1.0);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;script id&#x3D;&quot;bg_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n\n  uniform vec2 uTimes;\n\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n\n  void main(void) &#123;\n      vec3 col;\n      float c;\n      vec2 tmpv &#x3D; texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);\n      c &#x3D; exp(-pow(length(tmpv) * 1.8, 2.0));\n      col &#x3D; mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);\n      gl_FragColor &#x3D; vec4(col * 0.5, 1.0);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;script id&#x3D;&quot;fx_brightbuf_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n  uniform sampler2D uSrc;\n  uniform vec2 uDelta;\n\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n\n  void main(void) &#123;\n      vec4 col &#x3D; texture2D(uSrc, texCoord);\n      gl_FragColor &#x3D; vec4(col.rgb * 2.0 - vec3(0.5), 1.0);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;script id&#x3D;&quot;fx_dirblur_r4_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n  uniform sampler2D uSrc;\n  uniform vec2 uDelta;\n  uniform vec4 uBlurDir; &#x2F;&#x2F;dir(x, y), stride(z, w)\n\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n\n  void main(void) &#123;\n      vec4 col &#x3D; texture2D(uSrc, texCoord);\n      col &#x3D; col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);\n      col &#x3D; col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);\n      col &#x3D; col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);\n      col &#x3D; col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);\n      gl_FragColor &#x3D; col &#x2F; 5.0;\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;!-- effect fragment shader template --&gt;\n&lt;script id&#x3D;&quot;fx_common_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n  uniform sampler2D uSrc;\n  uniform vec2 uDelta;\n\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n\n  void main(void) &#123;\n      gl_FragColor &#x3D; texture2D(uSrc, texCoord);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;!-- post processing --&gt;\n&lt;script id&#x3D;&quot;pp_final_vsh&quot; type&#x3D;&quot;x-shader&#x2F;x_vertex&quot;&gt;\n  uniform vec3 uResolution;\n  attribute vec2 aPosition;\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n  void main(void) &#123;\n      gl_Position &#x3D; vec4(aPosition, 0.0, 1.0);\n      texCoord &#x3D; aPosition.xy * 0.5 + vec2(0.5, 0.5);\n      screenCoord &#x3D; aPosition.xy * vec2(uResolution.z, 1.0);\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;script id&#x3D;&quot;pp_final_fsh&quot; type&#x3D;&quot;x-shader&#x2F;x_fragment&quot;&gt;\n  #ifdef GL_ES\n  &#x2F;&#x2F;precision mediump float;\n  precision highp float;\n  #endif\n  uniform sampler2D uSrc;\n  uniform sampler2D uBloom;\n  uniform vec2 uDelta;\n  varying vec2 texCoord;\n  varying vec2 screenCoord;\n  void main(void) &#123;\n      vec4 srccol &#x3D; texture2D(uSrc, texCoord) * 2.0;\n      vec4 bloomcol &#x3D; texture2D(uBloom, texCoord);\n      vec4 col;\n      col &#x3D; srccol + bloomcol * (vec4(1.0) + srccol);\n      col *&#x3D; smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);\n      col &#x3D; pow(col, vec4(0.45454545454545)); &#x2F;&#x2F;(1.0 &#x2F; 2.2)\n\n      gl_FragColor &#x3D; vec4(col.rgb, 1.0);\n      gl_FragColor.a &#x3D; 1.0;\n  &#125;\n  &lt;&#x2F;script&gt;\n&lt;!-- partial --&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    &#x2F;&#x2F; Utilities\n    var Vector3 &#x3D; &#123;&#125;;\n    var Matrix44 &#x3D; &#123;&#125;;\n    Vector3.create &#x3D; function(x, y, z) &#123;\n        return &#123;&#39;x&#39;:x, &#39;y&#39;:y, &#39;z&#39;:z&#125;;\n    &#125;;\n    Vector3.dot &#x3D; function (v0, v1) &#123;\n        return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;\n    &#125;;\n    Vector3.cross &#x3D; function (v, v0, v1) &#123;\n        v.x &#x3D; v0.y * v1.z - v0.z * v1.y;\n        v.y &#x3D; v0.z * v1.x - v0.x * v1.z;\n        v.z &#x3D; v0.x * v1.y - v0.y * v1.x;\n    &#125;;\n    Vector3.normalize &#x3D; function (v) &#123;\n        var l &#x3D; v.x * v.x + v.y * v.y + v.z * v.z;\n        if(l &gt; 0.00001) &#123;\n            l &#x3D; 1.0 &#x2F; Math.sqrt(l);\n            v.x *&#x3D; l;\n            v.y *&#x3D; l;\n            v.z *&#x3D; l;\n        &#125;\n    &#125;;\n    Vector3.arrayForm &#x3D; function(v) &#123;\n        if(v.array) &#123;\n            v.array[0] &#x3D; v.x;\n            v.array[1] &#x3D; v.y;\n            v.array[2] &#x3D; v.z;\n        &#125;\n        else &#123;\n            v.array &#x3D; new Float32Array([v.x, v.y, v.z]);\n        &#125;\n        return v.array;\n    &#125;;\n    Matrix44.createIdentity &#x3D; function () &#123;\n        return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);\n    &#125;;\n    Matrix44.loadProjection &#x3D; function (m, aspect, vdeg, near, far) &#123;\n        var h &#x3D; near * Math.tan(vdeg * Math.PI &#x2F; 180.0 * 0.5) * 2.0;\n        var w &#x3D; h * aspect;\n\n        m[0] &#x3D; 2.0 * near &#x2F; w;\n        m[1] &#x3D; 0.0;\n        m[2] &#x3D; 0.0;\n        m[3] &#x3D; 0.0;\n\n        m[4] &#x3D; 0.0;\n        m[5] &#x3D; 2.0 * near &#x2F; h;\n        m[6] &#x3D; 0.0;\n        m[7] &#x3D; 0.0;\n\n        m[8] &#x3D; 0.0;\n        m[9] &#x3D; 0.0;\n        m[10] &#x3D; -(far + near) &#x2F; (far - near);\n        m[11] &#x3D; -1.0;\n\n        m[12] &#x3D; 0.0;\n        m[13] &#x3D; 0.0;\n        m[14] &#x3D; -2.0 * far * near &#x2F; (far - near);\n        m[15] &#x3D; 0.0;\n    &#125;;\n    Matrix44.loadLookAt &#x3D; function (m, vpos, vlook, vup) &#123;\n        var frontv &#x3D; Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z);\n        Vector3.normalize(frontv);\n        var sidev &#x3D; Vector3.create(1.0, 0.0, 0.0);\n        Vector3.cross(sidev, vup, frontv);\n        Vector3.normalize(sidev);\n        var topv &#x3D; Vector3.create(1.0, 0.0, 0.0);\n        Vector3.cross(topv, frontv, sidev);\n        Vector3.normalize(topv);\n\n        m[0] &#x3D; sidev.x;\n        m[1] &#x3D; topv.x;\n        m[2] &#x3D; frontv.x;\n        m[3] &#x3D; 0.0;\n\n        m[4] &#x3D; sidev.y;\n        m[5] &#x3D; topv.y;\n        m[6] &#x3D; frontv.y;\n        m[7] &#x3D; 0.0;\n\n        m[8] &#x3D; sidev.z;\n        m[9] &#x3D; topv.z;\n        m[10] &#x3D; frontv.z;\n        m[11] &#x3D; 0.0;\n\n        m[12] &#x3D; -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]);\n        m[13] &#x3D; -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]);\n        m[14] &#x3D; -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]);\n        m[15] &#x3D; 1.0;\n    &#125;;\n\n    &#x2F;&#x2F;\n    var timeInfo &#x3D; &#123;\n        &#39;start&#39;:0, &#39;prev&#39;:0, &#x2F;&#x2F; Date\n        &#39;delta&#39;:0, &#39;elapsed&#39;:0 &#x2F;&#x2F; Number(sec)\n    &#125;;\n\n    &#x2F;&#x2F;\n    var gl;\n    var renderSpec &#x3D; &#123;\n        &#39;width&#39;:0,\n        &#39;height&#39;:0,\n        &#39;aspect&#39;:1,\n        &#39;array&#39;:new Float32Array(3),\n        &#39;halfWidth&#39;:0,\n        &#39;halfHeight&#39;:0,\n        &#39;halfArray&#39;:new Float32Array(3)\n        &#x2F;&#x2F; and some render targets. see setViewport()\n    &#125;;\n    renderSpec.setSize &#x3D; function(w, h) &#123;\n        renderSpec.width &#x3D; w;\n        renderSpec.height &#x3D; h;\n        renderSpec.aspect &#x3D; renderSpec.width &#x2F; renderSpec.height;\n        renderSpec.array[0] &#x3D; renderSpec.width;\n        renderSpec.array[1] &#x3D; renderSpec.height;\n        renderSpec.array[2] &#x3D; renderSpec.aspect;\n\n        renderSpec.halfWidth &#x3D; Math.floor(w &#x2F; 2);\n        renderSpec.halfHeight &#x3D; Math.floor(h &#x2F; 2);\n        renderSpec.halfArray[0] &#x3D; renderSpec.halfWidth;\n        renderSpec.halfArray[1] &#x3D; renderSpec.halfHeight;\n        renderSpec.halfArray[2] &#x3D; renderSpec.halfWidth &#x2F; renderSpec.halfHeight;\n    &#125;;\n\n    function deleteRenderTarget(rt) &#123;\n        gl.deleteFramebuffer(rt.frameBuffer);\n        gl.deleteRenderbuffer(rt.renderBuffer);\n        gl.deleteTexture(rt.texture);\n    &#125;\n\n    function createRenderTarget(w, h) &#123;\n        var ret &#x3D; &#123;\n            &#39;width&#39;:w,\n            &#39;height&#39;:h,\n            &#39;sizeArray&#39;:new Float32Array([w, h, w &#x2F; h]),\n            &#39;dtxArray&#39;:new Float32Array([1.0 &#x2F; w, 1.0 &#x2F; h])\n        &#125;;\n        ret.frameBuffer &#x3D; gl.createFramebuffer();\n        ret.renderBuffer &#x3D; gl.createRenderbuffer();\n        ret.texture &#x3D; gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, ret.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0);\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer);\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return ret;\n    &#125;\n\n    function compileShader(shtype, shsrc) &#123;\n        var retsh &#x3D; gl.createShader(shtype);\n\n        gl.shaderSource(retsh, shsrc);\n        gl.compileShader(retsh);\n\n        if(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) &#123;\n            var errlog &#x3D; gl.getShaderInfoLog(retsh);\n            gl.deleteShader(retsh);\n            console.error(errlog);\n            return null;\n        &#125;\n        return retsh;\n    &#125;\n\n    function createShader(vtxsrc, frgsrc, uniformlist, attrlist) &#123;\n        var vsh &#x3D; compileShader(gl.VERTEX_SHADER, vtxsrc);\n        var fsh &#x3D; compileShader(gl.FRAGMENT_SHADER, frgsrc);\n\n        if(vsh &#x3D;&#x3D; null || fsh &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\n        var prog &#x3D; gl.createProgram();\n        gl.attachShader(prog, vsh);\n        gl.attachShader(prog, fsh);\n\n        gl.deleteShader(vsh);\n        gl.deleteShader(fsh);\n\n        gl.linkProgram(prog);\n        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) &#123;\n            var errlog &#x3D; gl.getProgramInfoLog(prog);\n            console.error(errlog);\n            return null;\n        &#125;\n\n        if(uniformlist) &#123;\n            prog.uniforms &#x3D; &#123;&#125;;\n            for(var i &#x3D; 0; i &lt; uniformlist.length; i++) &#123;\n                prog.uniforms[uniformlist[i]] &#x3D; gl.getUniformLocation(prog, uniformlist[i]);\n            &#125;\n        &#125;\n\n        if(attrlist) &#123;\n            prog.attributes &#x3D; &#123;&#125;;\n            for(var i &#x3D; 0; i &lt; attrlist.length; i++) &#123;\n                var attr &#x3D; attrlist[i];\n                prog.attributes[attr] &#x3D; gl.getAttribLocation(prog, attr);\n            &#125;\n        &#125;\n\n        return prog;\n    &#125;\n\n    function useShader(prog) &#123;\n        gl.useProgram(prog);\n        for(var attr in prog.attributes) &#123;\n            gl.enableVertexAttribArray(prog.attributes[attr]);;\n        &#125;\n    &#125;\n\n    function unuseShader(prog) &#123;\n        for(var attr in prog.attributes) &#123;\n            gl.disableVertexAttribArray(prog.attributes[attr]);;\n        &#125;\n        gl.useProgram(null);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    var projection &#x3D; &#123;\n        &#39;angle&#39;:60,\n        &#39;nearfar&#39;:new Float32Array([0.1, 100.0]),\n        &#39;matrix&#39;:Matrix44.createIdentity()\n    &#125;;\n    var camera &#x3D; &#123;\n        &#39;position&#39;:Vector3.create(0, 0, 100),\n        &#39;lookat&#39;:Vector3.create(0, 0, 0),\n        &#39;up&#39;:Vector3.create(0, 1, 0),\n        &#39;dof&#39;:Vector3.create(10.0, 4.0, 8.0),\n        &#39;matrix&#39;:Matrix44.createIdentity()\n    &#125;;\n\n    var pointFlower &#x3D; &#123;&#125;;\n    var meshFlower &#x3D; &#123;&#125;;\n    var sceneStandBy &#x3D; false;\n\n    var BlossomParticle &#x3D; function () &#123;\n        this.velocity &#x3D; new Array(3);\n        this.rotation &#x3D; new Array(3);\n        this.position &#x3D; new Array(3);\n        this.euler &#x3D; new Array(3);\n        this.size &#x3D; 1.0;\n        this.alpha &#x3D; 1.0;\n        this.zkey &#x3D; 0.0;\n    &#125;;\n\n    BlossomParticle.prototype.setVelocity &#x3D; function (vx, vy, vz) &#123;\n        this.velocity[0] &#x3D; vx;\n        this.velocity[1] &#x3D; vy;\n        this.velocity[2] &#x3D; vz;\n    &#125;;\n\n    BlossomParticle.prototype.setRotation &#x3D; function (rx, ry, rz) &#123;\n        this.rotation[0] &#x3D; rx;\n        this.rotation[1] &#x3D; ry;\n        this.rotation[2] &#x3D; rz;\n    &#125;;\n\n    BlossomParticle.prototype.setPosition &#x3D; function (nx, ny, nz) &#123;\n        this.position[0] &#x3D; nx;\n        this.position[1] &#x3D; ny;\n        this.position[2] &#x3D; nz;\n    &#125;;\n\n    BlossomParticle.prototype.setEulerAngles &#x3D; function (rx, ry, rz) &#123;\n        this.euler[0] &#x3D; rx;\n        this.euler[1] &#x3D; ry;\n        this.euler[2] &#x3D; rz;\n    &#125;;\n\n    BlossomParticle.prototype.setSize &#x3D; function (s) &#123;\n        this.size &#x3D; s;\n    &#125;;\n\n    BlossomParticle.prototype.update &#x3D; function (dt, et) &#123;\n        this.position[0] +&#x3D; this.velocity[0] * dt;\n        this.position[1] +&#x3D; this.velocity[1] * dt;\n        this.position[2] +&#x3D; this.velocity[2] * dt;\n\n        this.euler[0] +&#x3D; this.rotation[0] * dt;\n        this.euler[1] +&#x3D; this.rotation[1] * dt;\n        this.euler[2] +&#x3D; this.rotation[2] * dt;\n    &#125;;\n\n    function createPointFlowers() &#123;\n        &#x2F;&#x2F; get point sizes\n        var prm &#x3D; gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);\n        renderSpec.pointSize &#x3D; &#123;&#39;min&#39;:prm[0], &#39;max&#39;:prm[1]&#125;;\n\n        var vtxsrc &#x3D; document.getElementById(&quot;sakura_point_vsh&quot;).textContent;\n        var frgsrc &#x3D; document.getElementById(&quot;sakura_point_fsh&quot;).textContent;\n\n        pointFlower.program &#x3D; createShader(\n            vtxsrc, frgsrc,\n            [&#39;uProjection&#39;, &#39;uModelview&#39;, &#39;uResolution&#39;, &#39;uOffset&#39;, &#39;uDOF&#39;, &#39;uFade&#39;],\n            [&#39;aPosition&#39;, &#39;aEuler&#39;, &#39;aMisc&#39;]\n        );\n\n        useShader(pointFlower.program);\n        pointFlower.offset &#x3D; new Float32Array([0.0, 0.0, 0.0]);\n        pointFlower.fader &#x3D; Vector3.create(0.0, 10.0, 0.0);\n\n        &#x2F;&#x2F; paramerters: velocity[3], rotate[3]\n        pointFlower.numFlowers &#x3D; 1600;\n        pointFlower.particles &#x3D; new Array(pointFlower.numFlowers);\n        &#x2F;&#x2F; vertex attributes &#123;position[3], euler_xyz[3], size[1]&#125;\n        pointFlower.dataArray &#x3D; new Float32Array(pointFlower.numFlowers * (3 + 3 + 2));\n        pointFlower.positionArrayOffset &#x3D; 0;\n        pointFlower.eulerArrayOffset &#x3D; pointFlower.numFlowers * 3;\n        pointFlower.miscArrayOffset &#x3D; pointFlower.numFlowers * 6;\n\n        pointFlower.buffer &#x3D; gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        unuseShader(pointFlower.program);\n\n        for(var i &#x3D; 0; i &lt; pointFlower.numFlowers; i++) &#123;\n            pointFlower.particles[i] &#x3D; new BlossomParticle();\n        &#125;\n    &#125;\n\n    function initPointFlowers() &#123;\n        &#x2F;&#x2F;area\n        pointFlower.area &#x3D; Vector3.create(20.0, 20.0, 20.0);\n        pointFlower.area.x &#x3D; pointFlower.area.y * renderSpec.aspect;\n\n        pointFlower.fader.x &#x3D; 10.0; &#x2F;&#x2F;env fade start\n        pointFlower.fader.y &#x3D; pointFlower.area.z; &#x2F;&#x2F;env fade half\n        pointFlower.fader.z &#x3D; 0.1;  &#x2F;&#x2F;near fade start\n\n        &#x2F;&#x2F;particles\n        var PI2 &#x3D; Math.PI * 2.0;\n        var tmpv3 &#x3D; Vector3.create(0, 0, 0);\n        var tmpv &#x3D; 0;\n        var symmetryrand &#x3D; function() &#123;return (Math.random() * 2.0 - 1.0);&#125;;\n        for(var i &#x3D; 0; i &lt; pointFlower.numFlowers; i++) &#123;\n            var tmpprtcl &#x3D; pointFlower.particles[i];\n\n            &#x2F;&#x2F;velocity\n            tmpv3.x &#x3D; symmetryrand() * 0.3 + 0.8;\n            tmpv3.y &#x3D; symmetryrand() * 0.2 - 1.0;\n            tmpv3.z &#x3D; symmetryrand() * 0.3 + 0.5;\n            Vector3.normalize(tmpv3);\n            tmpv &#x3D; 2.0 + Math.random() * 1.0;\n            tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);\n\n            &#x2F;&#x2F;rotation\n            tmpprtcl.setRotation(\n                symmetryrand() * PI2 * 0.5,\n                symmetryrand() * PI2 * 0.5,\n                symmetryrand() * PI2 * 0.5\n            );\n\n            &#x2F;&#x2F;position\n            tmpprtcl.setPosition(\n                symmetryrand() * pointFlower.area.x,\n                symmetryrand() * pointFlower.area.y,\n                symmetryrand() * pointFlower.area.z\n            );\n\n            &#x2F;&#x2F;euler\n            tmpprtcl.setEulerAngles(\n                Math.random() * Math.PI * 2.0,\n                Math.random() * Math.PI * 2.0,\n                Math.random() * Math.PI * 2.0\n            );\n\n            &#x2F;&#x2F;size\n            tmpprtcl.setSize(0.9 + Math.random() * 0.1);\n        &#125;\n    &#125;\n\n    function renderPointFlowers() &#123;\n        &#x2F;&#x2F;update\n        var PI2 &#x3D; Math.PI * 2.0;\n        var limit &#x3D; [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];\n        var repeatPos &#x3D; function (prt, cmp, limit) &#123;\n            if(Math.abs(prt.position[cmp]) - prt.size * 0.5 &gt; limit) &#123;\n                &#x2F;&#x2F;out of area\n                if(prt.position[cmp] &gt; 0) &#123;\n                    prt.position[cmp] -&#x3D; limit * 2.0;\n                &#125;\n                else &#123;\n                    prt.position[cmp] +&#x3D; limit * 2.0;\n                &#125;\n            &#125;\n        &#125;;\n        var repeatEuler &#x3D; function (prt, cmp) &#123;\n            prt.euler[cmp] &#x3D; prt.euler[cmp] % PI2;\n            if(prt.euler[cmp] &lt; 0.0) &#123;\n                prt.euler[cmp] +&#x3D; PI2;\n            &#125;\n        &#125;;\n\n        for(var i &#x3D; 0; i &lt; pointFlower.numFlowers; i++) &#123;\n            var prtcl &#x3D; pointFlower.particles[i];\n            prtcl.update(timeInfo.delta, timeInfo.elapsed);\n            repeatPos(prtcl, 0, pointFlower.area.x);\n            repeatPos(prtcl, 1, pointFlower.area.y);\n            repeatPos(prtcl, 2, pointFlower.area.z);\n            repeatEuler(prtcl, 0);\n            repeatEuler(prtcl, 1);\n            repeatEuler(prtcl, 2);\n\n            prtcl.alpha &#x3D; 1.0;&#x2F;&#x2F;(pointFlower.area.z - prtcl.position[2]) * 0.5;\n\n            prtcl.zkey &#x3D; (camera.matrix[2] * prtcl.position[0]\n                + camera.matrix[6] * prtcl.position[1]\n                + camera.matrix[10] * prtcl.position[2]\n                + camera.matrix[14]);\n        &#125;\n\n        &#x2F;&#x2F; sort\n        pointFlower.particles.sort(function(p0, p1)&#123;return p0.zkey - p1.zkey;&#125;);\n\n        &#x2F;&#x2F; update data\n        var ipos &#x3D; pointFlower.positionArrayOffset;\n        var ieuler &#x3D; pointFlower.eulerArrayOffset;\n        var imisc &#x3D; pointFlower.miscArrayOffset;\n        for(var i &#x3D; 0; i &lt; pointFlower.numFlowers; i++) &#123;\n            var prtcl &#x3D; pointFlower.particles[i];\n            pointFlower.dataArray[ipos] &#x3D; prtcl.position[0];\n            pointFlower.dataArray[ipos + 1] &#x3D; prtcl.position[1];\n            pointFlower.dataArray[ipos + 2] &#x3D; prtcl.position[2];\n            ipos +&#x3D; 3;\n            pointFlower.dataArray[ieuler] &#x3D; prtcl.euler[0];\n            pointFlower.dataArray[ieuler + 1] &#x3D; prtcl.euler[1];\n            pointFlower.dataArray[ieuler + 2] &#x3D; prtcl.euler[2];\n            ieuler +&#x3D; 3;\n            pointFlower.dataArray[imisc] &#x3D; prtcl.size;\n            pointFlower.dataArray[imisc + 1] &#x3D; prtcl.alpha;\n            imisc +&#x3D; 2;\n        &#125;\n\n        &#x2F;&#x2F;draw\n        gl.enable(gl.BLEND);\n        &#x2F;&#x2F;gl.disable(gl.DEPTH_TEST);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n        var prog &#x3D; pointFlower.program;\n        useShader(prog);\n\n        gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix);\n        gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix);\n        gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n        gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof));\n        gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader));\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n\n        gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT);\n        gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT);\n        gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT);\n\n        &#x2F;&#x2F; doubler\n        for(var i &#x3D; 1; i &lt; 2; i++) &#123;\n            var zpos &#x3D; i * -2.0;\n            pointFlower.offset[0] &#x3D; pointFlower.area.x * -1.0;\n            pointFlower.offset[1] &#x3D; pointFlower.area.y * -1.0;\n            pointFlower.offset[2] &#x3D; pointFlower.area.z * zpos;\n            gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n            gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n            pointFlower.offset[0] &#x3D; pointFlower.area.x * -1.0;\n            pointFlower.offset[1] &#x3D; pointFlower.area.y *  1.0;\n            pointFlower.offset[2] &#x3D; pointFlower.area.z * zpos;\n            gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n            gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n            pointFlower.offset[0] &#x3D; pointFlower.area.x *  1.0;\n            pointFlower.offset[1] &#x3D; pointFlower.area.y * -1.0;\n            pointFlower.offset[2] &#x3D; pointFlower.area.z * zpos;\n            gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n            gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n            pointFlower.offset[0] &#x3D; pointFlower.area.x *  1.0;\n            pointFlower.offset[1] &#x3D; pointFlower.area.y *  1.0;\n            pointFlower.offset[2] &#x3D; pointFlower.area.z * zpos;\n            gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n            gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n        &#125;\n\n        &#x2F;&#x2F;main\n        pointFlower.offset[0] &#x3D; 0.0;\n        pointFlower.offset[1] &#x3D; 0.0;\n        pointFlower.offset[2] &#x3D; 0.0;\n        gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n        gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        unuseShader(prog);\n\n        gl.enable(gl.DEPTH_TEST);\n        gl.disable(gl.BLEND);\n    &#125;\n\n    &#x2F;&#x2F; effects\n    &#x2F;&#x2F;common util\n    function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) &#123;\n        var ret &#x3D; &#123;&#125;;\n        var unifs &#x3D; [&#39;uResolution&#39;, &#39;uSrc&#39;, &#39;uDelta&#39;];\n        if(exunifs) &#123;\n            unifs &#x3D; unifs.concat(exunifs);\n        &#125;\n        var attrs &#x3D; [&#39;aPosition&#39;];\n        if(exattrs) &#123;\n            attrs &#x3D; attrs.concat(exattrs);\n        &#125;\n\n        ret.program &#x3D; createShader(vtxsrc, frgsrc, unifs, attrs);\n        useShader(ret.program);\n\n        ret.dataArray &#x3D; new Float32Array([\n            -1.0, -1.0,\n            1.0, -1.0,\n            -1.0,  1.0,\n            1.0,  1.0\n        ]);\n        ret.buffer &#x3D; gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        unuseShader(ret.program);\n\n        return ret;\n    &#125;\n\n    &#x2F;&#x2F; basic usage\n    &#x2F;&#x2F; useEffect(prog, srctex(&#123;&#39;texture&#39;:texid, &#39;dtxArray&#39;:(f32)[dtx, dty]&#125;)); &#x2F;&#x2F;basic initialize\n    &#x2F;&#x2F; gl.uniform**(...); &#x2F;&#x2F;additional uniforms\n    &#x2F;&#x2F; drawEffect()\n    &#x2F;&#x2F; unuseEffect(prog)\n    &#x2F;&#x2F; TEXTURE0 makes src\n    function useEffect(fxobj, srctex) &#123;\n        var prog &#x3D; fxobj.program;\n        useShader(prog);\n        gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n\n        if(srctex !&#x3D; null) &#123;\n            gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray);\n            gl.uniform1i(prog.uniforms.uSrc, 0);\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, srctex.texture);\n        &#125;\n    &#125;\n    function drawEffect(fxobj) &#123;\n        gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer);\n        gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    &#125;\n    function unuseEffect(fxobj) &#123;\n        unuseShader(fxobj.program);\n    &#125;\n\n    var effectLib &#x3D; &#123;&#125;;\n    function createEffectLib() &#123;\n\n        var vtxsrc, frgsrc;\n        &#x2F;&#x2F;common\n        var cmnvtxsrc &#x3D; document.getElementById(&quot;fx_common_vsh&quot;).textContent;\n\n        &#x2F;&#x2F;background\n        frgsrc &#x3D; document.getElementById(&quot;bg_fsh&quot;).textContent;\n        effectLib.sceneBg &#x3D; createEffectProgram(cmnvtxsrc, frgsrc, [&#39;uTimes&#39;], null);\n\n        &#x2F;&#x2F; make brightpixels buffer\n        frgsrc &#x3D; document.getElementById(&quot;fx_brightbuf_fsh&quot;).textContent;\n        effectLib.mkBrightBuf &#x3D; createEffectProgram(cmnvtxsrc, frgsrc, null, null);\n\n        &#x2F;&#x2F; direction blur\n        frgsrc &#x3D; document.getElementById(&quot;fx_dirblur_r4_fsh&quot;).textContent;\n        effectLib.dirBlur &#x3D; createEffectProgram(cmnvtxsrc, frgsrc, [&#39;uBlurDir&#39;], null);\n\n        &#x2F;&#x2F;final composite\n        vtxsrc &#x3D; document.getElementById(&quot;pp_final_vsh&quot;).textContent;\n        frgsrc &#x3D; document.getElementById(&quot;pp_final_fsh&quot;).textContent;\n        effectLib.finalComp &#x3D; createEffectProgram(vtxsrc, frgsrc, [&#39;uBloom&#39;], null);\n    &#125;\n\n    &#x2F;&#x2F; background\n    function createBackground() &#123;\n        &#x2F;&#x2F;console.log(&quot;create background&quot;);\n    &#125;\n    function initBackground() &#123;\n        &#x2F;&#x2F;console.log(&quot;init background&quot;);\n    &#125;\n    function renderBackground() &#123;\n        gl.disable(gl.DEPTH_TEST);\n\n        useEffect(effectLib.sceneBg, null);\n        gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta);\n        drawEffect(effectLib.sceneBg);\n        unuseEffect(effectLib.sceneBg);\n\n        gl.enable(gl.DEPTH_TEST);\n    &#125;\n\n    &#x2F;&#x2F; post process\n    var postProcess &#x3D; &#123;&#125;;\n    function createPostProcess() &#123;\n        &#x2F;&#x2F;console.log(&quot;create post process&quot;);\n    &#125;\n    function initPostProcess() &#123;\n        &#x2F;&#x2F;console.log(&quot;init post process&quot;);\n    &#125;\n\n    function renderPostProcess() &#123;\n        gl.enable(gl.TEXTURE_2D);\n        gl.disable(gl.DEPTH_TEST);\n        var bindRT &#x3D; function (rt, isclear) &#123;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer);\n            gl.viewport(0, 0, rt.width, rt.height);\n            if(isclear) &#123;\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F;make bright buff\n        bindRT(renderSpec.wHalfRT0, true);\n        useEffect(effectLib.mkBrightBuf, renderSpec.mainRT);\n        drawEffect(effectLib.mkBrightBuf);\n        unuseEffect(effectLib.mkBrightBuf);\n\n        &#x2F;&#x2F; make bloom\n        for(var i &#x3D; 0; i &lt; 2; i++) &#123;\n            var p &#x3D; 1.5 + 1 * i;\n            var s &#x3D; 2.0 + 1 * i;\n            bindRT(renderSpec.wHalfRT1, true);\n            useEffect(effectLib.dirBlur, renderSpec.wHalfRT0);\n            gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0);\n            drawEffect(effectLib.dirBlur);\n            unuseEffect(effectLib.dirBlur);\n\n            bindRT(renderSpec.wHalfRT0, true);\n            useEffect(effectLib.dirBlur, renderSpec.wHalfRT1);\n            gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s);\n            drawEffect(effectLib.dirBlur);\n            unuseEffect(effectLib.dirBlur);\n        &#125;\n\n        &#x2F;&#x2F;display\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n        useEffect(effectLib.finalComp, renderSpec.mainRT);\n        gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture);\n        drawEffect(effectLib.finalComp);\n        unuseEffect(effectLib.finalComp);\n\n        gl.enable(gl.DEPTH_TEST);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n    var SceneEnv &#x3D; &#123;&#125;;\n    function createScene() &#123;\n        createEffectLib();\n        createBackground();\n        createPointFlowers();\n        createPostProcess();\n        sceneStandBy &#x3D; true;\n    &#125;\n\n    function initScene() &#123;\n        initBackground();\n        initPointFlowers();\n        initPostProcess();\n\n        &#x2F;&#x2F;camera.position.z &#x3D; 17.320508;\n        camera.position.z &#x3D; pointFlower.area.z + projection.nearfar[0];\n        projection.angle &#x3D; Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 &#x2F; Math.PI * 2.0;\n        Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]);\n    &#125;\n\n    function renderScene() &#123;\n        &#x2F;&#x2F;draw\n        Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up);\n\n        gl.enable(gl.DEPTH_TEST);\n\n        &#x2F;&#x2F;gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer);\n        gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height);\n        gl.clearColor(0.005, 0, 0.05, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n        renderBackground();\n        renderPointFlowers();\n        renderPostProcess();\n    &#125;\n\n    function onResize(e) &#123;\n        makeCanvasFullScreen(document.getElementById(&quot;sakura&quot;));\n        setViewports();\n        if(sceneStandBy) &#123;\n            initScene();\n        &#125;\n    &#125;\n\n    function setViewports() &#123;\n        renderSpec.setSize(gl.canvas.width, gl.canvas.height);\n\n        gl.clearColor(0.2, 0.2, 0.5, 1.0);\n        gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n\n        var rtfunc &#x3D; function (rtname, rtw, rth) &#123;\n            var rt &#x3D; renderSpec[rtname];\n            if(rt) deleteRenderTarget(rt);\n            renderSpec[rtname] &#x3D; createRenderTarget(rtw, rth);\n        &#125;;\n        rtfunc(&#39;mainRT&#39;, renderSpec.width, renderSpec.height);\n        rtfunc(&#39;wFullRT0&#39;, renderSpec.width, renderSpec.height);\n        rtfunc(&#39;wFullRT1&#39;, renderSpec.width, renderSpec.height);\n        rtfunc(&#39;wHalfRT0&#39;, renderSpec.halfWidth, renderSpec.halfHeight);\n        rtfunc(&#39;wHalfRT1&#39;, renderSpec.halfWidth, renderSpec.halfHeight);\n    &#125;\n\n    function render() &#123;\n        renderScene();\n    &#125;\n\n    var animating &#x3D; true;\n\n\n    function stepAnimation() &#123;\n        if(!animating) animate();\n    &#125;\n\n    function animate() &#123;\n        var curdate &#x3D; new Date();\n        timeInfo.elapsed &#x3D; (curdate - timeInfo.start) &#x2F; 1000.0;\n        timeInfo.delta &#x3D; (curdate - timeInfo.prev) &#x2F; 1000.0;\n        timeInfo.prev &#x3D; curdate;\n\n        if(animating) requestAnimationFrame(animate);\n        render();\n    &#125;\n\n    function makeCanvasFullScreen(canvas) &#123;\n        var b &#x3D; document.body;\n        var d &#x3D; document.documentElement;\n        var fullw &#x3D; Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth);\n        var fullh &#x3D; Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight);\n        canvas.width &#x3D; fullw;\n        canvas.height &#x3D; fullh;\n    &#125;\n\n    window.addEventListener(&#39;load&#39;, function(e) &#123;\n        var canvas &#x3D; document.getElementById(&quot;sakura&quot;);\n        try &#123;\n            makeCanvasFullScreen(canvas);\n            gl &#x3D; canvas.getContext(&#39;experimental-webgl&#39;);\n        &#125; catch(e) &#123;\n            alert(&quot;WebGL not supported.&quot; + e);\n            console.error(e);\n            return;\n        &#125;\n\n        window.addEventListener(&#39;resize&#39;, onResize);\n\n        setViewports();\n        createScene();\n        initScene();\n\n        timeInfo.start &#x3D; new Date();\n        timeInfo.prev &#x3D; timeInfo.start;\n        animate();\n    &#125;);\n\n    &#x2F;&#x2F;set window.requestAnimationFrame\n    (function (w, r) &#123;\n        w[&#39;r&#39;+r] &#x3D; w[&#39;r&#39;+r] || w[&#39;webkitR&#39;+r] || w[&#39;mozR&#39;+r] || w[&#39;msR&#39;+r] || w[&#39;oR&#39;+r] || function(c)&#123; w.setTimeout(c, 1000 &#x2F; 60); &#125;;\n    &#125;)(window, &#39;requestAnimationFrame&#39;);\n&lt;&#x2F;script&gt;\n\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;</code></pre>","text":"分享大家一个好看的 Login Page 代码 演示图 演示代码&lt;!-- Developer: @Arvin Explain: Login Page --...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"41 mins."},"categories":[{"name":"Web Page","slug":"Web-Page","count":3,"path":"api/categories/Web-Page.json"}],"tags":[{"name":"设计","slug":"设计","count":3,"path":"api/tags/设计.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA%E5%9B%BE\"><span class=\"toc-text\">演示图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">演示代码</span></a></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java 创建窗口","uid":"da69133c682847c464fcd9e3550d815c","slug":"CodeGame_Java_SuperMary_Test01","date":"2021-11-05T10:57:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Java_SuperMary_Test01.json","keywords":null,"cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.mRQUEYkDCy0aqlsBtq54zwHaJg?pid=ImgDet&rs=1","text":"Java 窗口绘制 创建窗口我们需要继承 JFrame 类 向窗口对象添加键盘监听器 需要该类实现 KeyListener 接口 并重写抽象方法 代码演示pac...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Error Page 设计演示01","uid":"922522eb16175498ad4c55c094fe3b58","slug":"design_ErrorPage_2021_10_31","date":"2021-10-30T17:23:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/design_ErrorPage_2021_10_31.json","keywords":null,"cover":"https://z3.ax1x.com/2021/10/31/5z70Rx.png","text":"分享大家一个好看的 Error Page 代码 演示图 演示代码&lt;!-- Developer: @Arvin Explain: Error Page --...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Web Page","slug":"Web-Page","count":3,"path":"api/categories/Web-Page.json"}],"tags":[{"name":"设计","slug":"设计","count":3,"path":"api/tags/设计.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}