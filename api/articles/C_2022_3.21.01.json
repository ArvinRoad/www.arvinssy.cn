{"title":"C语言文件操作","uid":"4bf8b9a001bc016f6215f57ed0fd32d2","slug":"C_2022_3.21.01","date":"2022-03-21T05:20:00.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/C_2022_3.21.01.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0","content":"<p>未完</p>\n<h2 id=\"6-0-文件基本操作\"><a href=\"#6-0-文件基本操作\" class=\"headerlink\" title=\"6.0 文件基本操作\"></a>6.0 文件基本操作</h2><p>对文件的操作我们所要采用指针，C语言创建之初是为了写unix系统，也就是后来的Linux系挺，它对文件是流的操控。<br>需要注意，如果使用完需要：fclose();<br>fclose 不光是关闭文件，还会把缓冲区的内容写入到文件。<br>缓冲区的作用：<br>缓冲区的作用实际上是用来包含我们的硬件的。<br>所有的磁盘都是有寿命限制的，每次读写对磁盘是有伤害的。<br>缓冲区是先集合要写的内容，然后统一写入进去</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\n\nFILE* fp &#x3D; NULL;        &#x2F;&#x2F; 可以将指针变量看成一个钥匙\nfp &#x3D; fopen(&quot;FILE\\\\Hello.txt&quot;, &quot;w+&quot;);        &#x2F;&#x2F; 第一个参数是&quot;文件路径和文件名称&quot; 第二个参数是模式 开门\nif (fp &#x3D;&#x3D; NULL) &#123;\nreturn -1;\n&#125;\n\nfclose(fp);        &#x2F;&#x2F; 关门\nfp &#x3D; NULL;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"fopen-的模式字符串\"><a href=\"#fopen-的模式字符串\" class=\"headerlink\" title=\"fopen() 的模式字符串\"></a>fopen() 的模式字符串</h3><p>fopen()参数说明：第一个参数是文件名称或文件路径，第二个则是文件模式字符串。</p>\n<table>\n<thead>\n<tr>\n<th>模式字符串</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>“r”</td>\n<td>以读的模式打开文件</td>\n</tr>\n<tr>\n<td>“w”</td>\n<td>以写的模式打开文件，把现有文件的长度截为0（清除内容），如果文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>“a”</td>\n<td>以写的模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>“r+”</td>\n<td>以更新模式打开文件（即可以读写文件）</td>\n</tr>\n<tr>\n<td>“w+”</td>\n<td>以更新模式打开文件（即，读和写），如果文件存在，则将其长度截为0（清楚内容），如果文件不存在，则创建一个新文件</td>\n</tr>\n<tr>\n<td>“a+”</td>\n<td>以更新模式打开文件（即，读和写），在现有文件的末尾添加内容，如果文件不存在，则创建一个新文件；可以读整个文件，但只能从尾部添加内容。</td>\n</tr>\n<tr>\n<td>“rb”、”wb”、”ab”、”ab+”、”a+b”、”wb+”、”w+b”、”ab+”、”a+b”</td>\n<td>以上个模式类似，但是以二进制模式，而不是文本模式打开文件</td>\n</tr>\n<tr>\n<td>“wx”、”wbx”、”w+x”、”wb+x”或”w+bx”</td>\n<td>（C11）类似非x模式，但是如果文件已经存在或以独占模式打开文件，则打开文件失败。</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-0-1-文件写入内容和文件缓冲区\"><a href=\"#6-0-1-文件写入内容和文件缓冲区\" class=\"headerlink\" title=\"6.0.1 文件写入内容和文件缓冲区\"></a>6.0.1 文件写入内容和文件缓冲区</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\nFILE* pf &#x3D; NULL;\npf &#x3D; fopen(&quot;FILE\\\\World.txt&quot;, &quot;w+&quot;);\n\nif (pf &#x3D;&#x3D; NULL) &#123;\nreturn -1;\n&#125;\n\nfputs(&quot;Hello World&quot;, pf);\n\n&#x2F;&#x2F; 断点 去文件里看看有没有数据，这样就可以看缓冲区\n\n&#x2F;**\n*        fputs不是把内容写入文件当中，而是写入到缓冲区。\n*        fclose 不光是关闭文件，还会把缓冲区的内容写入到文件。\n*        缓冲区的作用：\n*        缓冲区的作用实际上是用来包含我们的硬件的。\n*        所有的磁盘都是有寿命限制的，每次读写对磁盘是有伤害的。\n*        缓冲区是先集合要写的内容，然后统一写入进去\n*&#x2F;\n\nfclose(pf);\npf &#x3D; NULL;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h2 id=\"6-0-2-文件重定向\"><a href=\"#6-0-2-文件重定向\" class=\"headerlink\" title=\"6.0.2 文件重定向\"></a>6.0.2 文件重定向</h2><p>标准输入和标准输出<br>C的出现就是为了写系挺就是unix诞生的后来unix发展出众多系统(linux)<br>而系统操作最多的就是文件，以前用C语言的开发者都说一切皆是文件，这句话是对的。<br>因为C特殊就特殊在它把输入输出都当作文件，输入输出就是键盘和屏幕。C语言把所有的东西都看作是一个文件。<br>把键盘看作一个文件，把屏幕也看作是一个文件。打印机也看作一个文件，C语言的世界里只有文件。<br>重定向就是无论你是什么(软件|硬件),都可以相互转换。<br>重定向就是本来该显示在这里的东西可以显示在另一个地方。<br>重点：C语言一切皆文件。</p>\n<h3 id=\"文件重定向\"><a href=\"#文件重定向\" class=\"headerlink\" title=\"文件重定向\"></a>文件重定向</h3><p>Unix、Linux和当前的 DOS 版本都能够重定向输入和输出。输入重定向可以使程序能够使用文件代替键盘作为输入，输出重定向则使程序能够使用文件代替屏幕输出。<br>输出重定向就是用文本文件代替屏幕当作程序的输出，”&gt;” 运算符是另一个重定向运算符。假设我们要将键盘输入的数据发送至一个名为Test,.txt的文件。通过下面这条语句就可以完成：<br>Reput.exe&gt; Test.text。<br>该运算符会导致建立一个名为Test.txt的新文件供我们使用，然后将Reput.exe的输出（也就是说，我们嵌入的字符的副本）重定向到该文件。该重定向将stdout从显示设备（屏幕）重定向到Test.txt文件。<br>如果你已经有一个名为Test.txt的文件，则通常会删除该文件，然后再用新的文件代替。</p>\n<h3 id=\"重定向要点\"><a href=\"#重定向要点\" class=\"headerlink\" title=\"重定向要点\"></a>重定向要点</h3><p>重定向运算符是将一个可执行程序与一个数据文件链接起来，该运算符不能用于一个数据文件与另一个数据文件的链接，也不能用于一个程序和另一个程序的链接。<br>使用这些运算符时，输入不能来自一个以上的文件，输出也不能定向至一个以上的文件。<br>“&gt;&gt;” 运算符用累加的方法将数据输出到指定的文件上，不会覆盖已经有的数据，是在原基础上追加数据。</p>\n<h3 id=\"gets-函数的作用\"><a href=\"#gets-函数的作用\" class=\"headerlink\" title=\"gets 函数的作用\"></a>gets 函数的作用</h3><p>gets用来从标准设备读取字符并存放到参数s所指向的内存空间，直到出现换行字符或读到文件尾为止。<br>注意该函数目前C语言不推介使用了。C99 标准时候，委员会认为这个函数过于危险，很容易造成内存泄露（char ch[10] &#x3D; {0}; 在控制台输入大于定义的值它不会报错，运行完成后程序会自动崩溃），但以前的C语言代码都是用了这个函数，如果不用了，以前的代码就无法维护了，所以委员会支持该函数，但不建议使用。C11 标准认为可以废弃以前的代码将这个函数废弃。C11 建议放弃。但目前gets这个函数并没有废弃，还是可以使用，但建议放弃，C11 委员会推出了fgets供用户使用。（哈哈哈，C语言标准每年都很逗）</p>\n<h2 id=\"6-0-3-文件重定向二\"><a href=\"#6-0-3-文件重定向二\" class=\"headerlink\" title=\"6.0.3 文件重定向二\"></a>6.0.3 文件重定向二</h2><p>C语言把所有的设备当做文件来处理<br>C语言在进行文件操作时遵循如下步骤：打开-&gt; 读写操作-&gt; 关闭<br>C语言在程序中建立一个文件，本身就是结构体，然后返回的是一个结构体指针，文件指针是由操作系统来管理的。</p>\n<h3 id=\"文件指针的详细信息\"><a href=\"#文件指针的详细信息\" class=\"headerlink\" title=\"文件指针的详细信息\"></a>文件指针的详细信息</h3><p>FILE 类型详细底层实现</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">&#x2F;**\n*        C语言通过该结构体描述文件\n*&#x2F;\n\nstruct _iobuf &#123;\nchar* _ptr;                &#x2F;&#x2F; 当前缓冲区内容指针\nint _cnt;                &#x2F;&#x2F; 缓冲区还有多少字符\nchar* _base;        &#x2F;&#x2F; 缓冲区的起始地址\nint _flag;                &#x2F;&#x2F; 文件流的状态，是否错误或结束\nint _file;                &#x2F;&#x2F; 文件描述符\nint _charbuf;        &#x2F;&#x2F; 双字节缓存，缓存两个字节\nint _bufsiz;        &#x2F;&#x2F; 缓冲区大小\nchar* _tmpfname;&#x2F;&#x2F; 临时文件名\n&#125;;\ntypedef struct _iobuf FILE;</code></pre>\n<h3 id=\"标准输入与标准输出\"><a href=\"#标准输入与标准输出\" class=\"headerlink\" title=\"标准输入与标准输出\"></a>标准输入与标准输出</h3><p>通俗来说，打开是获取文件结构、系统为文件分配缓存中的过程，不打开文件就不能对其进行读写，关闭是释放缓冲区和其他资源的过程，不关闭文件就会慢慢耗光系统资源。<br>我们在进行文件操作时，系统自动与3个标准设备文件联系，这3个文件无需打开和关闭，它们的文件指针分别是：<br>stdin：标准输入文件指针，系统分配为键盘。<br>stdout：标准输出文件指针，系统分配为显示器。<br>stderr：标准错误输出文件指针，系统分配为显示器。</p>\n<h3 id=\"gets-函数废弃的原因\"><a href=\"#gets-函数废弃的原因\" class=\"headerlink\" title=\"gets 函数废弃的原因\"></a>gets 函数废弃的原因</h3><p>gets() 函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符”\\0”，使其成为一个c字符串。它经常和puts函数配对使用。该函数用于显示字符串，并在末尾添加换行符。</p>\n<p>问题在于gets()唯一一个参数是words，它无法检查数组是否装得下输入行，之前示例说过，数组名会被转换成数组的首元素的地址，因此gets()函数只知道数组的开始处，并不知道数组中可以放多少个元素。</p>\n<p>如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标控件。</p>\n<h3 id=\"fgets函数和gets函数的区别\"><a href=\"#fgets函数和gets函数的区别\" class=\"headerlink\" title=\"fgets函数和gets函数的区别\"></a>fgets函数和gets函数的区别</h3><p>fgets函数通过第二个参数限制读取字符的最大数量，如果该参数的值为n，那么fgets()将读入n-1个字符，或者读取遇到的第一个换行符为止。<br>fgets()函数读取到一个换行符，会把它存储在字符串中。这点与gets不同，gets()会丢弃换行符。<br>fgets()函数的第三个参数指明要读取的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h文件中。</p>\n<h3 id=\"fgets-函数的语法：\"><a href=\"#fgets-函数的语法：\" class=\"headerlink\" title=\"fgets()函数的语法：\"></a>fgets()函数的语法：</h3><p>fgets 是gets的替换版，三个参数：内存地址、可存储最大字节数、文件流<br>fgets(ch, 10, stdin);<br>这里第一个ch是我们用指针绑定的数组获取的数组指针，10则是绑定数组的数组大小，stdin是标准输入即表示键盘。<br>对应的还有一个输出叫：fputs()函数。</p>\n<h2 id=\"6-0-4-文件读取\"><a href=\"#6-0-4-文件读取\" class=\"headerlink\" title=\"6.0.4 文件读取\"></a>6.0.4 文件读取</h2><h3 id=\"fgetc-读取字符\"><a href=\"#fgetc-读取字符\" class=\"headerlink\" title=\"fgetc 读取字符\"></a>fgetc 读取字符</h3><p>从文件中读取一个字符，fgetc 只能读取窄字符。</p>\n<h3 id=\"feof的作用\"><a href=\"#feof的作用\" class=\"headerlink\" title=\"feof的作用\"></a>feof的作用</h3><p>检查文件流是否读到了文件尾。<br>函数说明：<br>feof用来检测是否读取到了文件尾，尾数stream 为 fopen() 所返回的文件指针。如果已经到文件尾，则返回非零值，其他情况返回0。<br>返回值：返回非零值代表已经到达文件末尾使用前面加上非。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\nchar ch &#x3D; 0;\nFILE* fp &#x3D; fopen(&quot;FILE\\\\World.txt&quot;, &quot;r&quot;);\nif (fp &#x3D;&#x3D; NULL) &#123;\nreturn -1;\n&#125;\n\nwhile (!feof(fp)) &#123;\nch &#x3D; fgetc(fp);        &#x2F;&#x2F; 获取，它一次只能读取一个字符\nprintf(&quot;%c&quot;, ch);\n&#125;\n\nfclose(fp);\nfp &#x3D; NULL;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h2 id=\"6-0-5-C语言获取文件大小\"><a href=\"#6-0-5-C语言获取文件大小\" class=\"headerlink\" title=\"6.0.5 C语言获取文件大小\"></a>6.0.5 C语言获取文件大小</h2><p>获取文件大小方法一：简单不建议使用（容易出错）<br>#define _CRT_SECURE_NO_WARNINGS<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>\n<p>void main68(void) {<br>char ch &#x3D; 0;<br>FILE* fp &#x3D; fopen(“FILE\\World.txt”, “r”);<br>if (fp &#x3D;&#x3D; NULL) {<br>return -1;<br>}<br>int i &#x3D; 0;</p>\n<p>while (!feof(fp)) {<br>ch &#x3D; fgetc(fp);        &#x2F;&#x2F; 获取，它一次只能读取一个字符<br>printf(“%c”, ch);<br>i++;<br>}</p>\n<p>fclose(fp);<br>fp &#x3D; NULL;<br>pringtf(“%d\\s”,i);</p>\n<p>printf(“\\n”);<br>system(“pause”);<br>}<br>获取文件大小方法二</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\n\nFILE* pf &#x3D; fopen(&quot;FILE\\\\World.txt&quot;, &quot;rb&quot;);\n\nif (pf &#x3D;&#x3D; NULL) &#123;\nreturn -1;\n&#125; else &#123;\n&#x2F;* 0代表偏移量 *&#x2F;\nfseek(pf, 0, SEEK_END);        &#x2F;&#x2F; 文件指针移动到末尾\nint length &#x3D; ftell(pf); &#x2F;&#x2F; 获取当前文件指针距离开头的长度\nfclose(pf);\nprintf(&quot;%d\\n&quot;, length);\npf &#x3D; NULL;\nreturn length;\n&#125;\n\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125; </code></pre>\n<h3 id=\"fseek-的作用\"><a href=\"#fseek-的作用\" class=\"headerlink\" title=\"fseek 的作用\"></a>fseek 的作用</h3><p>fseek() 用来移动文件流的读写位置。参数stream为已打开的文件指针，参数offset为根据参数whence来移动读写位置的位移数。<br>参数whence为下列其中一种：<br>SEEK_SET：从距文件开头，offset位移量为新的读写位置。<br>SEEK_CUR：以目前的读写位置往后增加offset个位移量。<br>SEEK_END：将读写位置指向文件尾后再增加offset个位移量。</p>\n<p>当whence值为SEEK_CUR或SEEK_END时，参数offset允许负值出现，下列是比较特别的使用方式：<br>欲将读写位置移动到文件开头时：<br>fseek(FILE* stream,0,SEEK_SET)<br>欲将读写位置移动到文件尾时：<br>fseek(FILE* stream,0,SEEK_END);</p>\n<p>函数返回值<br>当调用成功则返回0，若有错误则返回-1，error会存放错误代码</p>\n<p>附加说明：<br>fseek()不像lseek()会返回读写位置，因此必须使用ftell()来取得目前读写的位置。</p>\n","text":"未完 6.0 文件基本操作对文件的操作我们所要采用指针，C语言创建之初是为了写unix系统，也就是后来的Linux系挺，它对文件是流的操控。需要注意，如果使用完...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">6.0 文件基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fopen-%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">fopen() 的模式字符串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-1-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">6.0.1 文件写入内容和文件缓冲区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-2-%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">6.0.2 文件重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">文件重定向</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E5%90%91%E8%A6%81%E7%82%B9\"><span class=\"toc-text\">重定向要点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gets-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">gets 函数的作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-3-%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E4%BA%8C\"><span class=\"toc-text\">6.0.3 文件重定向二</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">文件指针的详细信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">标准输入与标准输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gets-%E5%87%BD%E6%95%B0%E5%BA%9F%E5%BC%83%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">gets 函数废弃的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fgets%E5%87%BD%E6%95%B0%E5%92%8Cgets%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">fgets函数和gets函数的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fgets-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">fgets()函数的语法：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-4-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">6.0.4 文件读取</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fgetc-%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6\"><span class=\"toc-text\">fgetc 读取字符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#feof%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">feof的作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-0-5-C%E8%AF%AD%E8%A8%80%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">6.0.5 C语言获取文件大小</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fseek-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">fseek 的作用</span></a></li></ol></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Three.Js开发WebGL创建三维空间","uid":"4091de74866dc5d796232e6bf95938a1","slug":"ThreeJsWebGL_2022_4.19.01","date":"2022-04-19T06:46:00.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/ThreeJsWebGL_2022_4.19.01.json","keywords":null,"cover":"https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg","text":"Three.Js开发WebGL创建三维空间首先我们需要创建一个 HTML 文件 如：index.html 导入Three.Js 与 设置网页初始化 (边距为0 ...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"博客网站","slug":"博客网站","count":6,"path":"api/tags/博客网站.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C语言指针(下)","uid":"df0891c5a177e6815a3b34e9b175010e","slug":"C_2022_3.13.01","date":"2022-03-13T06:22:00.000Z","updated":"2023-11-26T10:38:32.665Z","comments":true,"path":"api/articles/C_2022_3.13.01.json","keywords":null,"cover":"https://s1.ax1x.com/2022/03/13/bbLsWF.png","text":"5.1.0 内存四区模型操作系统把物理硬盘代码 load 到内存。操作系统把C代码分成四个区。操作系统找到Main函数入口执行。 内存四区一个由C&#x2F;C...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}