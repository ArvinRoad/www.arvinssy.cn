{"title":"C语言逻辑流程","uid":"283e767567236e303438acf396f39732","slug":"C_2022_3.07.01","date":"2022-03-07T07:55:00.000Z","updated":"2023-11-26T10:38:32.665Z","comments":true,"path":"api/articles/C_2022_3.07.01.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"4-0-函数\"><a href=\"#4-0-函数\" class=\"headerlink\" title=\"4.0. 函数\"></a>4.0. 函数</h2><p>程序的最小独立单元 - 语句<br>程序：为解决某一问题而设计的一系列有序指令的集合。<br>数据说明：数据的描述（数据的名称、类型、和初值等）<br>语句：如何处理数据的描述</p>\n<h3 id=\"函数的定义：\"><a href=\"#函数的定义：\" class=\"headerlink\" title=\"函数的定义：\"></a>函数的定义：</h3><h3 id=\"函数就是对某一特定功能的抽象\"><a href=\"#函数就是对某一特定功能的抽象\" class=\"headerlink\" title=\"函数就是对某一特定功能的抽象\"></a>函数就是对某一特定功能的抽象</h3><h3 id=\"函数的作用：\"><a href=\"#函数的作用：\" class=\"headerlink\" title=\"函数的作用：\"></a>函数的作用：</h3><h3 id=\"代码重用，模块化（便于定位错误）\"><a href=\"#代码重用，模块化（便于定位错误）\" class=\"headerlink\" title=\"代码重用，模块化（便于定位错误）\"></a>代码重用，模块化（便于定位错误）</h3><p>例：编写一个加法函数，参数为两个值，无返回值。</p>\n<h3 id=\"函数的分类\"><a href=\"#函数的分类\" class=\"headerlink\" title=\"函数的分类\"></a>函数的分类</h3><ul>\n<li>无参函数</li>\n</ul>\n<p>通过用来执行一些功能比较单一的语句<br>例如：getchar()</p>\n<ul>\n<li>有参函数</li>\n<li>通过处理传递过来的参数将函数值返回给主调函数</li>\n</ul>\n<p>Sin(),cos()</p>\n<ul>\n<li>库函数</li>\n</ul>\n<p>库函数分为标准库函数和第三方库函数。<br>库函数的特点：右C语言提供；用户无需定义，也不必再程序中做类型说明，只想要在程序前包含有该函数的头文件。<br>典型的如：system（）</p>\n<ul>\n<li>函数定义的语法格式：<br>函数定义有4个要素：参数列表，返回类型，函数名和函数体，参数列表和返回值类型，函数名用于和程序中其他实体区分，而函数体是一段可执行的代码块，实现特定的算法或功能。</li>\n</ul>\n<h3 id=\"函数调用的两种方式\"><a href=\"#函数调用的两种方式\" class=\"headerlink\" title=\"函数调用的两种方式\"></a>函数调用的两种方式</h3><ol>\n<li>函数调用有两种类型，一是”先定义，后调用”，这要求函数定义和调用语句在同一个文件内，编译器能从函数定义中提取函数的参数列表、输出类型等接口信息。</li>\n</ol>\n<p>如果没有函数的定义，就想要将函数实例写在主调用函数之前。<br>举例：函数声明和调用在一个文件内：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid add(int a,int b);\n\nint main() &#123;\n\nint num1,num2;\nprintf(&quot;请输入数值a：&quot;);\nscanf(&quot;%d&quot;, &amp;num1);\nprintf(&quot;\\n请输入数值b：&quot;);\nscanf(&quot;%d&quot;, &amp;num2);\nadd(num1,num2);\nsystem(&quot;pause&quot;);\nreturn 30;\n&#125;\n\nvoid add(int a, int b) &#123;\nint c &#x3D; a + b;\nprintf(&quot;a+b &#x3D; %d\\n&quot;, c);\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>二是”函数声明+函数调用” 大多数情况下，函数的定义与函数的调用，并吧在一个文件内，即使在一个文件中也有可能调用在前而定义在后，这时想要，在调用之前先对函数声明，告诉编译器有这么一个函数的存在。</li>\n</ol>\n<p>举例：函数的跨文件调用</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;* 头文件 函数.h *&#x2F;\n#pragma once        &#x2F;&#x2F; 防止头文件重复包含\n#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid Hello() &#123;\nprintf(&quot;Hello World\\n&quot;);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 源文件\n#include &quot;4.0 函数.h&quot;\n\n&#x2F;* 函数的定义 *&#x2F;\nvoid add(int a,int b);\n\nint main() &#123;\n\nint num1,num2;\nprintf(&quot;请输入数值a：&quot;);\nscanf(&quot;%d&quot;, &amp;num1);\nprintf(&quot;\\n请输入数值b：&quot;);\nscanf(&quot;%d&quot;, &amp;num2);\nadd(num1,num2);\nHello();\nsystem(&quot;pause&quot;);\nreturn 30;\n&#125;\n\nvoid add(int a, int b) &#123;\nint c &#x3D; a + b;\nprintf(&quot;a+b &#x3D; %d\\n&quot;, c);\n&#125;</code></pre>\n<h3 id=\"函数注意事项：\"><a href=\"#函数注意事项：\" class=\"headerlink\" title=\"函数注意事项：\"></a>函数注意事项：</h3><ul>\n<li>函数的定义在程序中都是平行的，即不允许在一个函数的内部调用（再写）另一个函数。</li>\n<li>函数名是用户自定义标识符，当函数值为整型时类型名可省略。当函数不需要向调用出返回值时，使用void类型名。</li>\n<li>形参列表中的形参是用户自定义标识符，没有参数时，圆括号不能省略，此时函数为无参函数。</li>\n<li>函数在没有声明的时候必须写在主调函数Main之前否则会出错。因为程序是自上而下执行的</li>\n</ul>\n<h2 id=\"4-1-数组\"><a href=\"#4-1-数组\" class=\"headerlink\" title=\"4.1. 数组\"></a>4.1. 数组</h2><h3 id=\"数组的概念\"><a href=\"#数组的概念\" class=\"headerlink\" title=\"数组的概念\"></a>数组的概念</h3><ol>\n<li>数组的概念：</li>\n</ol>\n<p>数组是可以在内存中连续存储多个元素的结构<br>数组中的所有元素必须属于相同的数据类型<br>举例：int a[5] &#x3D; {0,1,2,3,4}; printf(“&amp;a”);<br>在内存中查看连续的5个元素</p>\n<ol>\n<li>数组语法</li>\n</ol>\n<p>类型数组名[数组元素个数] &#x3D; {数组元素}；</p>\n<p>例如：int a[10] &#x3D; {0};</p>\n<p>int a[] &#x3D; {1,2,3};  &#x2F;&#x2F; 当数组元素确定的时候数组个数可以省略</p>\n<p>int a[5] &#x3D; {1,2,3};  &#x2F;&#x2F; 不足填充0</p>\n<p>printf(“%d\\n”, sizeof(a) &#x2F; sizeof(int));&#x2F;&#x2F; 查看数组元素的个数</p>\n<p>一组数组就好比对货物的编号。<br>注意：数组的下标是从0开始的。数组在内存中是连续排列的<br>告诉编译器4条信息：数组名是a，存放的元素是int型，数组存放的元素个数为10，元素值为0，这样便可以对数组及数组元素进行读写访问。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define N 5        &#x2F;&#x2F; 只需要修改常量就可以修改数组和循环函数的值\n\nvoid main() &#123;\n\nint a[N] &#x3D; &#123;1,2,3,4,5&#125;;\n\nfor (int i &#x3D; 0; i &lt; N; i++) &#123;\nprintf(&quot;%d\\n&quot;, a[i]);\n&#125;\n\nprintf(&quot;%p\\n&quot;, &amp;a);        &#x2F;&#x2F; %p用来输出指针类型自身的值\n\nprintf(&quot;%d\\n&quot;, sizeof(a)); &#x2F;&#x2F; 查看a数组大小 1int &#x3D; 4 4*5 &#x3D; 20字节\nprintf(&quot;%d\\n&quot;, sizeof(a) &#x2F; sizeof(int));        &#x2F;&#x2F; 查看数组元素的个数\n\n&#x2F;* 循环打印数组地址 *&#x2F;\nfor (int i &#x3D; 0; i &lt; N; i++) &#123;\nprintf(&quot;a[%d] &#x3D; %d &amp;a[%d] &#x3D; %x\\n&quot;, i, a[i], i, &amp;a[i]);        &#x2F;&#x2F;X 打印地址 P也打印地址\n&#125;\n&#x2F;*  数组 &#x3D; 值 数组 &#x3D; 地址\na[0] &#x3D; 1 &amp;a[0] &#x3D; bc36f638\na[1] &#x3D; 2 &amp;a[1] &#x3D; bc36f63c\na[2] &#x3D; 3 &amp;a[2] &#x3D; bc36f640\na[3] &#x3D; 4 &amp;a[3] &#x3D; bc36f644\na[4] &#x3D; 5 &amp;a[4] &#x3D; bc36f648\n*&#x2F;\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h2 id=\"4-1-1-二维数组\"><a href=\"#4-1-1-二维数组\" class=\"headerlink\" title=\"4.1.1 二维数组\"></a>4.1.1 二维数组</h2><ol>\n<li>概念</li>\n</ol>\n<p>一维数组常称为向量，二维数组，最简单的理解是”有两个下标”，如果把一维数组理解为一行数据，那么，二维数组可形象地表示为行列结构。X Y就是二维，X Y Z 就是三维<br>例子：int a[2][3] &#x3D; {1,2,3,4,5,6}<br>其中第一个方括号中的元素代表行，第二个方括号中的元素代表列</p>\n<table>\n<thead>\n<tr>\n<th>身高&#124;体态</th>\n<th>丰满的</th>\n<th>苗条的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>修长的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>小巧玲珑的</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>查看数组在内存当中的分布。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() &#123;\n\n&#x2F;&#x2F; 存储了3*5 &#x3D; 15个元素        3行5列 一行5个元素\nint a[3][5] &#x3D; &#123; &#123; 1,2,3,4,5 &#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125; &#125;;\n\nprintf(&quot;%p\\n&quot;, &amp;a);\nprintf(&quot;%d\\n&quot;, sizeof(a));        &#x2F;&#x2F; 大小是 60 4字节*15元素 &#x3D; 60字节\nprintf(&quot;%d\\n&quot;, sizeof(a) &#x2F; sizeof(int));        &#x2F;&#x2F; 60字节 &#x2F; 4字节 &#x3D; 15元素\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n\n<ol>\n<li>初始化二维数组</li>\n</ol>\n<p>注意：二维数组中的元素同样是给分配在一段连续的内存<br>初始化表达式中内层花括号代表一行，这样和一维数组中只能对前几个元素初始化不同，二维数组的初始化可以跳过某些中间元素，给后面的元素赋值。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[2][3] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;</code></pre>\n\n<p>也可以这样初始化：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int a[][4] &#x3D; &#123;&#123;1,2,3,4&#125;&#125;;</code></pre>\n\n<p>大括号初始化了以后，行号可以省略</p>\n<h3 id=\"两种赋值方法：\"><a href=\"#两种赋值方法：\" class=\"headerlink\" title=\"两种赋值方法：\"></a>两种赋值方法：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() &#123;\n\n&#x2F;&#x2F; 存储了3*5 &#x3D; 15个元素        3行5列 一行5个元素\nint a[3][5] &#x3D; &#123; &#123; 1,2,3,4,5 &#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125; &#125;;\n\nprintf(&quot;%p\\n&quot;, &amp;a);\n\nprintf(&quot;%d\\n&quot;, sizeof(a));        &#x2F;&#x2F; 大小是 60 4字节*15元素 &#x3D; 60字节\nprintf(&quot;%d\\n&quot;, sizeof(a) &#x2F; sizeof(int));        &#x2F;&#x2F; 60字节 &#x2F; 4字节 &#x3D; 15元素\n\n&#x2F;* 二维数组赋值方法 *&#x2F;\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nfor (int j &#x3D; 0; j &lt; 5; j++) &#123;\nprintf(&quot;a &#x3D; %d\\n&quot;, a[i][j]);\n&#125;\n&#125;\nprintf(&quot;------------------------------------------------\\n&quot;);\n\nint b[3][5] &#x3D; &#123; 0 &#125;;\nint c[3][5] &#x3D; &#123; 0 &#125;;\nfor (int i &#x3D; 0; i &lt; 15; i++) &#123;\nb[i &#x2F; 5][i % 5] &#x3D; i;\n&#125;\n\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nfor (int j &#x3D; 0; j &lt; 5; j++) &#123;\nc[i][j] &#x3D; i * 5 + j + 1;\n&#125;\n&#125;\n\nfor (int i &#x3D; 0; i &lt; 3; i++)&#123;\nfor (int j &#x3D; 0; j &lt; 5; j++) &#123;\nprintf(&quot;b &#x3D; %d\\n&quot;, b[i][j]);\n&#125;\n&#125;\n\nprintf(&quot;------------------------------------------------\\n&quot;);\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nfor (int j &#x3D; 0; j &lt; 5; j++) &#123;\nprintf(&quot;c &#x3D; %d\\n&quot;, c[i][j]);\n&#125;\n&#125;\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"二维数组地址的引用\"><a href=\"#二维数组地址的引用\" class=\"headerlink\" title=\"二维数组地址的引用\"></a>二维数组地址的引用</h3><p>元素a[i][j]的地址是&amp;a[i][j];二维数组的数组名代表该数组的首地址；<br>比如：a实际上就是&amp;a[0][0]。二维数组元素在内存中按行存放，第一行的首地址为a[0]第二行的首地址为a[1]，……，第n行的首地址为a[n-1]；<br>&amp;a[i][j]等价于 a[i]+j。</p>\n<h2 id=\"4-2-基础算法\"><a href=\"#4-2-基础算法\" class=\"headerlink\" title=\"4.2 基础算法\"></a>4.2 基础算法</h2><h3 id=\"选择排序法\"><a href=\"#选择排序法\" class=\"headerlink\" title=\"选择排序法\"></a>选择排序法</h3><ol>\n<li>如何看懂带算法的程序<ol>\n<li>看流程判断和循环条件</li>\n<li>搞清楚每个语句的功能</li>\n<li>试数</li>\n<li>调试</li>\n<li>模仿改</li>\n</ol>\n</li>\n<li>选择排序法求极值</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() &#123;\n\nint a[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,0 &#125;;\n\nint Max &#x3D; a[0];        &#x2F;&#x2F; 初始化 Max &#x3D; 1 然后去比较如果a[i]大于Max 那将a[i]的值赋予Max\n\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n&#x2F;&#x2F; 这行打断点，打开局部变量调试查看\nif (Max &lt; a[i]) &#123;\nMax &#x3D; a[i];\n&#125;\n&#125;\nprintf(&quot;Max(最大值)的值为：%d\\n&quot;, Max);\n\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n&#x2F;&#x2F; 这行打断点，打开局部变量调试查看\nif (Max &gt; a[i]) &#123;\nMax &#x3D; a[i];\n&#125;\n&#125;\nprintf(&quot;最小值为：%d\\n&quot;, Max);\n\nint i &#x3D; 0;\nwhile (i &lt; 10) &#123;\ni++;\nif (Max &lt; a[i]) &#123;\nMax &#x3D; a[i];\n&#125;\n&#125;\nprintf(&quot;while循环下Max的值为：%d\\n&quot;, Max);\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<p>选择排序方法一：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        假设初始化 Max 的值是最大的\n*        Max &#x3D; i 在每次循环中加1 然后用 Max 去循环和 j 比较\n*        如果 j 大于 Max 就交换位置\n*        \n*        Max &#x3D; a[0] &#x3D; 1 | j &#x3D; i+1 &#x3D; 2 | &#x3D; 2 1\n*        内循环第一次最终结果：2,1,3,4,5,6,7,8,9,0\n*        内循环第二次最终结果：3,1,2,4,5,6,7,8,9,0\n*        外循环第一次最终结果：9,1,2,3,4,5,6,7,8,0\n*        外循环第二次最终结果：9,8,1,2,3,4,5,6,7,0\n*        外循环第三次最终结果：9,8,7,1,2,3,4,5,6,0\n* \n*        总结：\n*        选择排序法 按住一个位置不动 循环出一个最大值\n*        就好比打擂台 1挑全部 挑完一个再进行下一个\n*        \n*&#x2F;\n\nvoid main() &#123;\n\nint a[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,0 &#125;;\n\nint Max &#x3D; 0;\n\nfor (int i &#x3D; 0; i &lt; 10 - 1; i++) &#123;        &#x2F;&#x2F; 最后剩余一个数肯定最小就不用比较了 所以减一\nMax &#x3D; i;\nfor (int j &#x3D; i + 1; j &lt; 10; j++) &#123;\nif (a[Max] &lt; a[j]) &#123;\nint team &#x3D; a[j];\na[j] &#x3D; a[Max];\na[Max] &#x3D; team;\n&#125;\n&#125;\n\n&#x2F;* 逐步分析结果 *&#x2F;\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot; %4d&quot;, a[i]);\n&#125;\nprintf(&quot;\\n&quot;);\n\n&#125;\n\nprintf(&quot;------------- 最终结果 ---------------\\n&quot;);\n\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot;a 的值为：%d\\n&quot;, a[i]);\n&#125;\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<p>选择排序法方法二（优化）：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        10 个人当老大\n*   我只和其中最厉害的打\n*&#x2F;\n\nvoid main() &#123;\n\nint a[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,0 &#125;;\nint Max &#x3D; 0;\n\nfor (int i &#x3D; 0; i &lt; 10 - 1; i++) &#123;\nMax &#x3D; i;\nfor (int j &#x3D; i + 1; j &lt; 10; j++) &#123;\nif (a[Max] &lt; a[j]) &#123;\nMax &#x3D; j;        &#x2F;&#x2F; 存储 j 的下标 不直接交换 只比较不交换\n&#125;\n&#125;\nif (Max !&#x3D; i) &#123;\nint team &#x3D; a[i];\na[i] &#x3D; a[Max];\na[Max] &#x3D; team;\n\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot;%4d&quot;, a[i]);\n&#125;\n&#125;\nprintf(&quot;------------- 最终结果 ---------------\\n&quot;);\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot;%4d\\n&quot;, a[i]);\n&#125;\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"冒泡排序法\"><a href=\"#冒泡排序法\" class=\"headerlink\" title=\"冒泡排序法\"></a>冒泡排序法</h3><p>冒泡排序法求极值</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n&#x2F;**\n*  冒泡算法是两两的进行比较 9和8比较 8和7比较 如果大就相互交换\n*&#x2F;\n\nvoid main() &#123;\n\nint a[10] &#x3D; &#123; 9,8,7,6,5,4,3,2,1,0 &#125;;\n\nfor (int i &#x3D; 0; i &lt; 10 - 1; i++) &#123;\n\nif (a[i] &gt; a[i + 1]) &#123;\nint team &#x3D; a[i + 1];\na[i + 1] &#x3D; a[i];\na[i] &#x3D; team;\n&#125;\n&#125;\n\nprintf(&quot;a 的最大值为：%d\\n&quot;,a[9]);\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n\n<p>冒泡排序法</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        冒泡排序法\n*        和选择排序法不同，选择排序法是固定一个值去比较大小\n*        冒泡排序法是两两进行比较\n*&#x2F;\n\nvoid main37() &#123;\n\nint a[10] &#x3D; &#123; 9,8,7,6,5,4,3,2,1,0 &#125;;\n\nfor (int i &#x3D; 0; i &lt; 10 - 1; i++) &#123;\n&#x2F;&#x2F; i每循环一次都会筛选出最大值\nfor (int j &#x3D; 0; j &lt; 10 - 1 - i; j++) &#123;                &#x2F;&#x2F;-i 是因为一个数已经在底了，所以就不用循环它了\nif (a[j] &gt; a[j + 1]) &#123;\nint team &#x3D; a[j + 1];\na[j + 1] &#x3D; a[j];\na[j] &#x3D; team;\n&#125;\n&#125;\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot;%4d&quot;, a[i]);\n&#125;\nprintf(&quot;\\n&quot;);\n&#125;\n\nprintf(&quot;\\n------------- 最终结果 ---------------\\n&quot;);\n\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\nprintf(&quot;%d\\n&quot;, a[i]);\n&#125;\n\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"二分查找法\"><a href=\"#二分查找法\" class=\"headerlink\" title=\"二分查找法\"></a>二分查找法</h3><p>二分查找法用于快速查找信息或数据，当然还有更快的方法插值算法<br>二分查找法，是去一段数据的中间值，我们用中间值和我们的数据进行比较，如果我们的数大于中间值，那么小于中间值的我们就不需要进行比较。<br>然后我们找到需要进行比较的头和尾，再去中间值进行判断去排除。反复的循环就可以找到我们需要的数<br>例如：<br>我们有一个数组从1-12，我们需要的数值是9。<br>那么我们可以算出1-12的中间值为6。<br>6和9进行比较，9大于6那么1-6都排除，<br>我们重新定义7为数据的头12为数据的尾。<br>假设我们定义11为中间值，9是小于11的那么11-12就可以排除<br>我们定义7-10为头和尾进行比较。以此类推我们就可以获取到我们的值。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid FindNum(int a[], int data);\n\n&#x2F;&#x2F; 当然还有更快的算法：插值算法\n\nvoid main() &#123;\n\nint a[1000] &#x3D; &#123; 0 &#125;;\nfor (int i &#x3D; 0; i &lt; 1000; i++) &#123;\na[i] &#x3D; i;\nprintf(&quot;i &#x3D; %d\\n&quot;,i);        &#x2F;&#x2F; 打印出数值赋值的数\n&#125;\n\nint data;\nprintf(&quot;请输入您要查询的值：&quot;);\nscanf(&quot;%d&quot;,&amp;data);\n\nFindNum(a,data);\n\nsystem(&quot;pause&quot;);\n&#125;\n\nvoid FindNum(int a[], int data) &#123;\nint head &#x3D; 0;\nint foot &#x3D; 1000 - 1;\nint flag &#x3D; -2;        &#x2F;&#x2F; 找到与没找到的判断值\nint ci &#x3D; 0;        &#x2F;&#x2F; 排除次数\nwhile (head &lt;&#x3D; foot) &#123;\nint median &#x3D; (head + foot) &#x2F; 2;\nprintf(&quot;head 的值：%d Foot的值：%d Median的值：%d 次数：%d\\n&quot;,head,foot,median,++ci);\nif (data &#x3D;&#x3D; a[median]) &#123;\nprintf(&quot;找到了 data的值为：%d\\n&quot;, data);\nflag &#x3D; 1;\nbreak;\n&#125;else if (data &gt; a[median]) &#123;        &#x2F;&#x2F; 值大于中间值，小于中间值的全部值被抛弃\nhead &#x3D; median + 1;\n\n&#125;else &#123;        &#x2F;&#x2F; 值小于中间值，大于中间值的全部值被抛弃\nfoot &#x3D; median - 1;\n&#125;\n&#125;\n\nif (flag &#x3D;&#x3D; -2) &#123;        &#x2F;&#x2F; 如果找不到这个值\nprintf(&quot;找不到这个值\\n&quot;);\n&#125;\n\n\n&#125;</code></pre>\n","text":"4.0. 函数程序的最小独立单元 - 语句程序：为解决某一问题而设计的一系列有序指令的集合。数据说明：数据的描述（数据的名称、类型、和初值等）语句：如何处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-0-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.0. 函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A\"><span class=\"toc-text\">函数的定义：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%B0%B1%E6%98%AF%E5%AF%B9%E6%9F%90%E4%B8%80%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">函数就是对某一特定功能的抽象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">函数的作用：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%BE%BF%E4%BA%8E%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%EF%BC%89\"><span class=\"toc-text\">代码重用，模块化（便于定位错误）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">函数的分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">函数调用的两种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A\"><span class=\"toc-text\">函数注意事项：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">4.1. 数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">数组的概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">4.1.1 二维数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">两种赋值方法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">二维数组地址的引用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4.2 基础算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95\"><span class=\"toc-text\">选择排序法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95\"><span class=\"toc-text\">冒泡排序法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95\"><span class=\"toc-text\">二分查找法</span></a></li></ol></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"WebServer构建","uid":"d16e3307a16ecb822048b7d5e1538015","slug":"WebServer_2022_3.08.01","date":"2022-03-07T19:55:00.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/WebServer_2022_3.08.01.json","keywords":null,"cover":"https://img.php.cn/upload/article/000/000/020/5e91393a49cb1970.jpg","text":"注意：该项目是采用C语言调用 WindowsAPI 进行实现的，如果不掌握简单的网络通信协议和C语言与Windows API 编程请先掌握后再来看。 什么是协议...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"初识汇编","uid":"a552bb9adfdeebd36af5d88c9d032505","slug":"Assembly_2022_3.6.01","date":"2022-03-06T09:37:00.000Z","updated":"2023-11-26T10:38:32.665Z","comments":true,"path":"api/articles/Assembly_2022_3.6.01.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.713f092ccdb317f1f0c087f3539f7cab?rik=bOE%2bVTWSO1ntvA&riu=http%3a%2f%2fi1.hdslb.com%2fbfs%2farchive%2fde6d0f9a0cc0e1ccae53a428089163f10b795a9d.jpg&ehk=7dDrxNiIDQOVlzPnHk42gtOex6jz9ANqVywfOJIg2lk%3d&risl=&pid=ImgRaw&r=0","text":"汇编语言是用计算机的思维去操作计算机。 汇编语言概述汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构（重点主要在：CPU与内存），才能有效的应用汇...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"},{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}