{"title":"C语言指针(下)","uid":"df0891c5a177e6815a3b34e9b175010e","slug":"C_2022_3.13.01","date":"2022-03-13T06:22:00.000Z","updated":"2023-11-26T10:38:32.665Z","comments":true,"path":"api/articles/C_2022_3.13.01.json","keywords":null,"cover":"https://s1.ax1x.com/2022/03/13/bbLsWF.png","content":"<h2 id=\"5-1-0-内存四区模型\"><a href=\"#5-1-0-内存四区模型\" class=\"headerlink\" title=\"5.1.0 内存四区模型\"></a>5.1.0 内存四区模型</h2><p><a href=\"https://imgtu.com/i/bbLsWF\"><img src=\"https://s1.ax1x.com/2022/03/13/bbLsWF.png\" alt=\"内存四区图\"></a><br>操作系统把物理硬盘代码 load 到内存。<br>操作系统把C代码分成四个区。<br>操作系统找到Main函数入口执行。</p>\n<h3 id=\"内存四区\"><a href=\"#内存四区\" class=\"headerlink\" title=\"内存四区\"></a>内存四区</h3><p>一个由C&#x2F;C++编译的程序占用的内存分成以下几个部分：<br>栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。只有汇编语言可以操控栈区。</p>\n<p>堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能操作系统回收。<br>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>\n<p>数据区：主要包括静态全局区和常量区，如果要站在汇编的角度细分的话，还可以分为很多小区。</p>\n<p>全局区（静态区）（static）：全局变量和静态变量的存储放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。常量区也存在于全局区（他们统称）。</p>\n<p>常量区：常量字符串就是放在这里的，程序结束后由系统释放。</p>\n<p>代码区：存放函数体的二进制代码。由操作系统管理，函数指针最强大的地方就是可以操作代码区的数据。</p>\n<h3 id=\"全局区详解\"><a href=\"#全局区详解\" class=\"headerlink\" title=\"全局区详解\"></a>全局区详解</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;Windows.h&gt;\n\nchar* pMem1();        &#x2F;&#x2F; 函数指针\nchar* pMem2();\nchar* pMem3();\n\nvoid main(void) &#123;\nchar* p1 &#x3D; NULL;        &#x2F;&#x2F;声明两个指针变量\nchar* p2 &#x3D; NULL;\nchar* p3 &#x3D; NULL;\np1 &#x3D; pMem1();        &#x2F;&#x2F; 接收函数指针传出的指针变量值\np2 &#x3D; pMem2();\np3 &#x3D; pMem3();\n\nprintf(&quot;p1 &#x3D; %s p1 &#x3D; %p\\n&quot;, p1, p1);\nprintf(&quot;p2 &#x3D; %s p2 &#x3D; %p\\n&quot;, p2, p2);\nprintf(&quot;p3 &#x3D; %s p3 &#x3D; %p\\n&quot;, p3, p3);\nsystem(&quot;pause&quot;);\n&#125;\n\nchar* pMem1() &#123;\n&#x2F;**\n*        两个不同的函数定义了一个相同的字符串，地址一样吗？\n*        是一样的，实际上它存储的是字符串的地址，栈区运行完毕就自动销毁了，实际上这两个函数是一样的只是函数名不一样\n*        同样的东西，为什么要创建两次呢？设计者也不是傻子。\n*        例如有一个货物放在哪里不动了，这个时候他们两个人分别去记录这个货物的位置。\n*        栈区上的变量执行完毕变量就销毁了\n*&#x2F;\nchar* p1 &#x3D; &quot;Hello World&quot;;        &#x2F;&#x2F; 存储在全局区\nreturn p1;        &#x2F;&#x2F; 返回一个指针变量\n&#125;\n\n&#x2F;&#x2F; 函数调用完毕，内存销毁\nchar* pMem2() &#123;\n&#x2F;**\n*        Hello Arvin 这个字符串怎么传入到这个指针的呢？指针变量在32Bit下是4字节，64Bit下是8字节。\n*        指针变量存储的只存储的是它的地址，变量实际在全局区。\n*&#x2F;\nchar* p2 &#x3D; &quot;Hello World&quot;;\nreturn p2;\n&#125;\n\nchar* pMem3() &#123;\n&#x2F;&#x2F; 如果货物不一样，那么他们的地址就不一样。\nchar* p3 &#x3D; &quot;Hello Arvin&quot;;\nreturn p3;\n&#125;</code></pre>\n<p>总结：<br>全局区相同字符串常量合并。<br>注意三点：<br>栈区调用完毕就销毁了。<br>指针指向谁就把谁的地址赋值给指针。<br>%s 的意思就是打印地址所指向的内容。</p>\n<h3 id=\"栈区详解\"><a href=\"#栈区详解\" class=\"headerlink\" title=\"栈区详解\"></a>栈区详解</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nchar* p_str();\n\nvoid main() &#123;\n\nchar* p &#x3D; NULL;\np &#x3D; p_str();\n\nprintf(&quot;P &#x3D; %s\\n&quot;, p);        &#x2F;&#x2F; 数组的首地址 \n\n&#x2F;**\n*  那么p打印这个地址所队友的内存空间内容是不是 Hello 答案是否因为已经被栈销毁了\n*  说明：p_str在栈区创建一块100字节的空间，&quot;Hello&quot; 还是存放在全局区。\n*  p_str是一个数组，复制了全局变量的内容，拷贝了一份在栈上和地址无关。\n*  当p_str函数执行完毕后，将p_str的地址返回给Main的p，然后p_str会自动销毁。所以无法输出获取 Hello。\n*&#x2F;\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;\n\nchar* p_str() &#123;\nchar str[100] &#x3D; &quot;Hello&quot;;        &#x2F;&#x2F; 4字节\nprintf(&quot;str &#x3D; %s\\n&quot;,str);\nreturn str;\n&#125;</code></pre>\n<p>内存栈区调试</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        两个函数声明同一个变量，这两个变量有关系吗？ ：没有\n*&#x2F;\n\nchar* p_str2();\n\nvoid main(void) &#123;\n\nchar* p &#x3D; NULL;\np &#x3D; p_str2();\n\nprintf(&quot;p &#x3D; %s\\n&quot;, p);\nprintf(&quot;p &#x3D; %p\\n&quot;, p);\n\n&#x2F;&#x2F; 在这里再打一个断点运行查看内存\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;\n\nchar* p_str2() &#123;\nchar str[100] &#x3D; &quot;Hello&quot;;\nprintf(&quot;str &#x3D; %s\\n&quot;, str);\nprintf(&quot;str &#x3D; %p\\n&quot;, str);\n&#x2F;&#x2F; 查看栈销毁，在这里打一个断点\nreturn str;\n&#125;</code></pre>\n<p>所以在栈上开辟一个数组是很危险的，所以我们一般在堆上开辟数组。堆是由我们控制的所以在使用完成后要手动释放。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"堆区详解\"><a href=\"#堆区详解\" class=\"headerlink\" title=\"堆区详解\"></a>堆区详解</h3><h4 id=\"strcpy-函数的作用\"><a href=\"#strcpy-函数的作用\" class=\"headerlink\" title=\"strcpy 函数的作用\"></a><em>strcpy 函数的作用</em></h4><p>原型声明：char<em>strcpy(char</em> dest,const char* src);<br>功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。<br>说明：stc和dest所指内存区域不可以重叠，且dest必须有足够的空间来容纳src的字符串。<br>返回指向dest的指针。</p>\n<p>堆区不会自动释放需要手动释放。<br>Free 的意思不是清空内存，而是解除这个指针的绑定关系（解除和这块内存的绑定关系），原先只有指针自己能调用，（取消绑定后）现在谁都可以用。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        运行流程说明：\n*        首先在栈区创建了指针p，现在指针p为NULL；\n*        然后执行phead函数，它入栈，创建了一个指针tmp(存储堆区的地址)。在堆区创建了一个100字节大小的空间。\n*        strcpy拷贝Hello到堆区。然后将tmp(堆区地址)返回给main函数中创建的p，栈区销毁phead指针函数。\n*        p接收到堆区的地址，进行判断，如果不为NULL，就打印出它指针指向的地址的内容。\n*        然后解除指针变量p和堆内存的绑定关系。将指针变量p置空。\n*&#x2F;\n\nchar* phead();\n\nvoid main(void) &#123;\nchar* p &#x3D; NULL;\np &#x3D; phead();\nprintf(&quot;p &#x3D; %p\\n&quot;, p);\nprintf(&quot;p &#x3D; %s\\n&quot;, p);\nif (p !&#x3D; NULL) &#123;        &#x2F;&#x2F; 如果p接收到的不为NULL，就打印出它指针指向地址的内容\nprintf(&quot;%s\\n&quot;, p);\n&#x2F;&#x2F; 断点\nfree(p);        &#x2F;&#x2F; 解除指针变量p和堆内存的绑定关系。\np &#x3D; NULL;        &#x2F;&#x2F; 将指针变量p置空\n&#125;\n&#x2F;&#x2F; 断点\nsystem(&quot;pause&quot;);\n&#125;\n\nchar* phead() &#123;\nchar* tmp &#x3D; (char*)malloc(100);        &#x2F;&#x2F; 在堆上开辟了100字节的空间\nif (tmp &#x3D;&#x3D; NULL) &#123;        &#x2F;&#x2F; 如果tmp为空那么就返回一个空的值。\nreturn NULL;\n&#125;\nstrcpy(tmp, &quot;Hello&quot;);        &#x2F;&#x2F; strcpy拷贝函数，我们将Hello拷贝到tmp指向的空间(我们在堆里开辟的空间)\nprintf(&quot;tmp &#x3D; %p\\n&quot;, tmp);\nprintf(&quot;tmp &#x3D; %s\\n&quot;, tmp);\n&#x2F;&#x2F; 断点\nreturn tmp;\n&#125;</code></pre>\n\n<h2 id=\"5-1-2-指针运算（重点）\"><a href=\"#5-1-2-指针运算（重点）\" class=\"headerlink\" title=\"5.1.2 指针运算（重点）\"></a>5.1.2 指针运算（重点）</h2><p>指针的加减法,它是处理多级指针包括数组的时候非常重要。它决定了你在指针这里能走多远。严格来说，指针很少有人走到头。至少要掌握二级指针到三级指针（否则你将很难明白C++语言中的引用）。<br>void *p是一个万能指针。</p>\n<p>指针的数据类型决定了指针的解析方式，同时也决定了指针的步长。<br>指针+1等于指针加上所指向类型的大小。<br>编译器对指针+1的操作：p+sizeof（<em>p）</em>1；</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;&#x2F;51\nvoid main() &#123;\nint num &#x3D; 10;\nint* p &#x3D; &amp;num;\nprintf(&quot;%p %p\\n&quot;, p, p + 1);        &#x2F;&#x2F; 指针是4|8字节，指针+1 &#x3D; +4字节\nprintf(&quot;%d %d\\n&quot;, p, p + 1);        &#x2F;&#x2F; 证实指针+1 &#x3D; +4 注意：指针+1 等于指针所指向类型的大小\n\nchar str &#x3D; &#39;a&#39;;\nchar* p_str &#x3D; &amp;str;\n&#x2F;&#x2F; 指针+1在编译器实际是：p+sizeof(*p)*1\nprintf(&quot;%p %p\\n&quot;, p_str, p_str + 1);        &#x2F;&#x2F; 这里指针+1 &#x3D; +1字节 因为char是一个字节\nprintf(&quot;%d %d\\n&quot;, p_str, p_str + 1);\n\n&#x2F;**\n*        既然指针都是4|8字节，那么为什么要有类型呢？注意：void *p 是万能指针。\n*        其实指针变量的类型决定了解析的方式，声明什么类型的变量就要用什么类型的指针变量。\n*        如果用错了会出现错误，类型不单单决定了步长，还决定了解析方式。\n*        步长：+1加多少就是步长。指针的类型决定了指针的步长(往前走几个字节)\n*        类型相当于模具，变量相当于做出的模型，如果模具不一样做做出来的模具肯定会出现问题。\n*&#x2F;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"指针与数组练习\"><a href=\"#指针与数组练习\" class=\"headerlink\" title=\"指针与数组练习\"></a>指针与数组练习</h3><p>指针也是一种数据类型，指针的数据类型是指它所指向的内存空间的数据类型。<br>指针的空间和指针所指向的内存空间是不同概念。<br>下面实例比较复杂建议多看内存和多思考。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() &#123;\nchar str[] &#x3D; &quot;Hello&quot;;\n\n&#x2F;&#x2F; 字符串是以\\0结尾的所以是6个字节 或者智能去判断\n&#x2F;*for (int i &#x3D; 0; i &lt; sizeof(str); i++) &#123;\nprintf(&quot;%c&quot;, str[i]);\n&#125;\nprintf(&quot;\\n\\n&quot;);*&#x2F;\n\n&#x2F;* 我们采用指针的方式打印 *&#x2F; &#x2F;&#x2F; 这里断点调试，注释上面for内容\nfor (char* p_str &#x3D; str; p_str &lt; str + 3; p_str++) &#123;\nprintf(&quot;%c&quot;, *p_str);\n&#125;\n&#x2F;**\n*        for(指针绑定地址，指针小于数组字符串，p_str++(步长))\n*        数组+1是加了本身一个元素的大小\n*        p_str+1是加了指向类型的大小\n*        指针变量和数组的起始点是一样的，步长也是一样的\n*        所以值也一样\n*&#x2F;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"指针的间接赋值\"><a href=\"#指针的间接赋值\" class=\"headerlink\" title=\"指针的间接赋值\"></a>指针的间接赋值</h3><p>如果想通过形参改变实参的内存内容（值）必须地址传递。<br>指针间接赋值的三个条件<br>两个变量、建立关系、通过*操作内存</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        问题：怎么通过形参改变一个函数内实参的值？从外部更改函数内部的值\n*        函数的参数有副本机制(重新开辟一个内存)，除了数组。\n*        采用指针的方式从外部修改内部的值\n*&#x2F;\n\nint num(int a);\n&#x2F;* 我们采用指针的方式从外部修改内部的值 *&#x2F;\nvoid pnum(int *a);\n\nvoid main() &#123;\nint a &#x3D; 20;\nprintf(&quot;main a &#x3D; %p\\n&quot;, &amp;a);\nint b &#x3D; num(a);        &#x2F;&#x2F; 我们传入num的a的值为20 那么输出是10 还是 20：答案是：10 (创建副本)\n\nprintf(&quot;b &#x3D; %d\\n&quot;, b);\n\nint c &#x3D; 100;\npnum(&amp;c);\nprintf(&quot;c &#x3D; %d\\n&quot;, c);\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;\n\nint num(int a) &#123;\na &#x3D; 10;\nprintf(&quot;num  a &#x3D; %p\\n&quot;, &amp;a);\nreturn a;\n&#125;\n\nvoid pnum(int* a) &#123;\n*a &#x3D; 10;\n&#125;</code></pre>\n<h3 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h3><p>指针数组实际上就是指针类型的数组。<br>当然还有一种叫数组指针，实际上就是指向数组的指针。<br>注意：指针数组是指针类型的数组，数组指针是指向数组的指针</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\nint a &#x3D; 1;\nint b &#x3D; 2;\nint c &#x3D; 3;\n\nint d[4] &#x3D; &#123; 1,2,3,4 &#125;;\n\nfor (int i &#x3D; 0; i &lt; 4; i++) &#123;\nprintf(&quot;%d\\n&quot;, d[i]);\n&#125;\n\nchar *pa[] &#x3D; &#123; &quot;a&quot;,&quot;b&quot;,&quot;c&quot; &#125;;        &#x2F;&#x2F; 指针数组 &quot;a&quot;在指针常量区，&quot;a&quot;存储的实际上是地址\n&#x2F;&#x2F; 当然还有一种叫数组指针，实际上就是指向数组的指针\n&#x2F;&#x2F; 注意：指针数组是指针类型的数组，数组指针是指向数组的指针\n&#x2F;&#x2F; 断点\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;        &#x2F;&#x2F; 这里+1是加了一个地址的长度\nprintf(&quot;%s\\n&quot;, pa[i]);        &#x2F;&#x2F; 这里i也是一个地址的长度\n&#125;\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h2 id=\"5-1-3-结构体基本操作\"><a href=\"#5-1-3-结构体基本操作\" class=\"headerlink\" title=\"5.1.3 结构体基本操作\"></a>5.1.3 结构体基本操作</h2><p>结构体类型定义<br>结构体变量定义<br>结构体变量初始化<br>Typedef 改变类型名<br>注意：结构体也是一种数据类型，是我们自定义的类型。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        结构体就是自定义的数据类型语法：struct 类型名好比我们的int float。\n*&#x2F;\n\n&#x2F;* 结构体类型定义第一种方式 *&#x2F;\nstruct Test &#123;\nchar face[10];\nint EyesSize;\n\n&#125;;\n\n&#x2F;* 结构体变量定义第一种方式 (声明赋值二合一) *&#x2F;\nstruct Test test &#x3D; &#123; &quot;Hello&quot;,20 &#125;;        &#x2F;&#x2F; 和定义 int a;一样，但是结构体是struct Test &#x3D;&#x3D; int\n\n&#x2F;* 结构体类型定义第二种方式 *&#x2F;\nstruct Test02 &#123;\nchar face[10];\nint EyesSize;\n&#125;test02 &#x3D; &#123;&quot;World&quot;,15&#125;;        &#x2F;&#x2F; 直接在下面定义变量\n\n&#x2F;* 结构体类型定义第三种 *&#x2F;\nstruct &#123;\nchar face[10];\nint EyesSize;\n&#125;test03,test04;        &#x2F;&#x2F; 匿名结构体，这个结构体只能使用在下面定义好的变量\n\n&#x2F;* 结构体类型定义第四种 *&#x2F;\ntypedef struct Test05 &#123;\nchar face[10];\nint EyesSize;\n&#125;Test05;        &#x2F;&#x2F; tyoedef 是别名，它将 struct Test05 替换成 Test05 这样我们就可以少写一个\n\nTest05 test05 &#x3D; &#123; &quot;Love&quot;,520 &#125;;\n\nvoid main() &#123;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h3><p>注意：<br>Test结构体它声明的时候是不开辟内存的，你必须初始化对象才开辟内存。<br>箭头运算符 ：用于指针来调用变量的一种方式。<br>test.face &#x3D; { “Hello” }; 这样的化会出错，它不是指针(不能往指针的地址里拷贝字符串)。所以我们要用到Strcpy函数。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Test &#123;\nchar face[10];\nint EyesSize;\nchar* str;\n&#125;Test;\n\nvoid main(void) &#123;\nTest test;\n&#x2F;&#x2F; test.face &#x3D; &#123; &quot;Hello&quot; &#125;; 这样的化会出错，它不是指针(不能往指针的地址里拷贝字符串)。所以我们要用到Strcpy函数\nstrcpy(test.face,&quot;Hello&quot;);\ntest.str &#x3D; &quot;World&quot;;\ntest.EyesSize &#x3D; 15;\nfor (char* p &#x3D; test.str; p &lt; test.str + 6; p++) &#123;\nprintf(&quot;%c&quot;, *p);\n&#125;\n\nTest test02 &#x3D; &#123; &quot;Hello&quot;,15,&quot;Arvin&quot;&#125;;\nprintf(&quot;%s %d\\n&quot;, test.face, test.EyesSize);\nprintf(&quot;%s %d %s\\n&quot;, test02.face, test02.EyesSize, test02.str);\n\nTest test01;\n&#x2F;* 箭头运算符 ：用于指针来调用变量的一种方式 *&#x2F;\nTest* p_test &#x3D; NULL;        &#x2F;&#x2F; 这个指针指向我们的结构体\np_test &#x3D; &amp;test01;        &#x2F;&#x2F; 初始化一个结构体的对象\nstrcpy(p_test-&gt;face, &quot;Hello&quot;);\np_test-&gt;EyesSize &#x3D; 100;        &#x2F;&#x2F; 指针通过箭头运算符调用结构体里的内容\np_test-&gt;str &#x3D; &quot;World&quot;;\nprintf(&quot;%s %d %s\\n&quot;, p_test-&gt;face, p_test-&gt;EyesSize, p_test-&gt;str);\n\n&#x2F;**\n*        报错：Test结构体它声明的时候是不开辟内存的，你必须初始化对象才开辟内存。\n*&#x2F;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<p>如果你在p_test-&gt;EyesSize &#x3D; 100;非要用*的方式也不是不可以：<br>(*p_test).EyesSize &#x3D; 100;</p>\n<h3 id=\"结构体变量之间赋值\"><a href=\"#结构体变量之间赋值\" class=\"headerlink\" title=\"结构体变量之间赋值\"></a>结构体变量之间赋值</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        我们定义结构体的时候不开辟内存。\n*        在声明变量的时候才会开辟内存 ModelFace modelFace &#x3D; &#123; &quot;Hello&quot;,50 &#125;;\n*        注意：赋值完成后它们就没有关系了\n*&#x2F;\n\ntypedef struct ModelFace &#123;\nchar face[10];\nint EyesSize;\n&#125;ModelFace;\n\nvoid main56(void) &#123;\nModelFace modelFace &#x3D; &#123; &quot;Hello&quot;,50 &#125;;\n\n&#x2F;* 结构体变量之间可以相互赋值 *&#x2F;\nModelFace modeF &#x3D; modelFace;\n\nprintf(&quot;%s %d\\n&quot;, modeF.face, modeF.EyesSize);\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"结构体静态数组-栈区\"><a href=\"#结构体静态数组-栈区\" class=\"headerlink\" title=\"结构体静态数组-栈区\"></a>结构体静态数组-栈区</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        结构体定义数组-在栈区开辟\n*        注意类比\n*&#x2F;\ntypedef struct ModelFace &#123;\nchar face[10];\nint EyesSize;\n&#125;ModelFace;\n\nvoid main() &#123;\nint a[3] &#x3D; &#123; 1,2,3 &#125;;\n\n&#x2F;* 结构体数组有两种定义方式 *&#x2F;\nModelFace modelFace[3] &#x3D; &#123; &quot;Gun&quot;,100,&quot;Liyun&quot;,50,&quot;Note&quot;,10 &#125;;\nModelFace modelF[3] &#x3D; &#123; &#123;&quot;Fun&quot;,100&#125;,&#123;&quot;Miun&quot;,50&#125;,&#123;&quot;Mote&quot;,10&#125; &#125;;\n\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nprintf(&quot;ModeFace：%d %s %d\\n&quot;, i, modelFace[i].face, modelFace[i].EyesSize);\nprintf(&quot;ModeF   ：%d %s %d\\n&quot;, i, modelF[i].face, modelF[i].EyesSize);\n&#125;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"结构体动态数组-堆区\"><a href=\"#结构体动态数组-堆区\" class=\"headerlink\" title=\"结构体动态数组-堆区\"></a>结构体动态数组-堆区</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        结构体动态数组-堆区\n*        注意类比\n*&#x2F;\n\nstruct ModelFace &#123;\nchar face[10];\nint EyesSize;\n&#125;;\n\nvoid main() &#123;\n\nint a[3] &#x3D; &#123; 0 &#125;;\nint* pa &#x3D; (int*)malloc(3 * sizeof(int)); &#x2F;&#x2F; 开辟堆区内存\nfree(pa);\npa &#x3D; NULL;\n\n&#x2F;* 结构体动态数组 *&#x2F;\nstruct ModelFace modelFace[3] &#x3D; &#123; 0 &#125;;\nstruct ModelFace* p_str &#x3D; (struct ModelFace*)malloc(3 * sizeof(struct ModelFace));\nif (p_str &#x3D;&#x3D; NULL) &#123;\nreturn NULL;\n&#125;\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nstrcpy(p_str[i].face, &quot;Arvin&quot;);\np_str[i].EyesSize &#x3D; 10 + i;\n&#125;\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\nprintf(&quot;modelFace %d ：%s %d\\n&quot;, i, p_str[i].face, p_str[i].EyesSize);\n&#125;\nif (p_str !&#x3D; NULL) &#123;\nfree(p_str);\np_str &#x3D; NULL;\n&#125;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"结构体嵌套数组\"><a href=\"#结构体嵌套数组\" class=\"headerlink\" title=\"结构体嵌套数组\"></a>结构体嵌套数组</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n&#x2F;**\n*        结构体嵌套指针\n*        如果结构体内部有个指针能否直接给指针拷贝内容：答案是可以的\n*&#x2F;\n\n\ntypedef struct ModelFace &#123;\nchar* face;\nint EyesSize;\n&#125;ModelFace;\n\nvoid main59(void) &#123;\nprintf(&quot;请输入您的姓名：&quot;);\nchar Mname[10] &#x3D; &#123; 0 &#125;;\nint* age &#x3D; 0;\nscanf(&quot;%s&quot;,Mname);\nchar* name &#x3D; NULL;\nname &#x3D; (char*)malloc(10);\nstrcpy(name, Mname);\nprintf(&quot;name：%s\\n&quot;, name);\nif (name !&#x3D; NULL) &#123;\nfree(name);\nname &#x3D; NULL;\n&#125;\n&#x2F;* 结构体 *&#x2F;\nModelFace modelFace;\nmodelFace.face &#x3D; (char*)malloc(10);\nstrcpy(modelFace.face, Mname);\nmodelFace.EyesSize &#x3D; 18;\nprintf(&quot;ModeFace：name:%s age:%d&quot;, modelFace.face, modelFace.EyesSize);\nif (modelFace.face !&#x3D; NULL) &#123;\nfree(modelFace.face);\nmodelFace.face &#x3D; NULL;\n&#125;\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"结构体赋值细节\"><a href=\"#结构体赋值细节\" class=\"headerlink\" title=\"结构体赋值细节\"></a>结构体赋值细节</h3><p>在程序流程时如果你不知道大小可以采用strlen函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">for (int i &#x3D; 0; i &lt; strlen(Name); i++) &#123;        &#x2F;&#x2F; 如果你不知道大小可以采用strlen函数\npMyStruct-&gt;hello[i] &#x3D; Name[i];\n&#125;</code></pre>\n<p>结构体赋值第一部分</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct MyStruct &#123;\nchar hello[10];\nint a;        &#x2F;&#x2F;第二次加个一个int类型测试\n&#125;MyStruct;\n\nvoid main() &#123;\nint a;\nprintf(&quot;a：%d\\n&quot;, sizeof(a));        &#x2F;&#x2F; 4字节，int是系统做好的类型\n\nMyStruct myStruct;\nprintf(&quot;myStruct：%d\\n&quot;, sizeof(myStruct));        &#x2F;&#x2F; 10字节，我们自定义变量 加上int为16字节（因为结构体内存对齐）\nstrcpy(myStruct.hello, &quot;A&quot;);\nprintf(&quot;myStruct.hello：%d\\n&quot;, sizeof(myStruct.hello));\nprintf(&quot;myStruct.a：%d\\n&quot;, sizeof(myStruct.a));        &#x2F;&#x2F; 4字节，为什么会消失2字节？\n\n&#x2F;**\n* 结构体在开辟内存的时候，可能因为变量不同。系统会不确定分配多少内存。\n* 所以会尽可能的分配大一点的内存，按照结构体里最大类型的2的倍数进行分配。\n*&#x2F;\n\nMyStruct* pMyStruct &#x3D; &amp;myStruct;\nprintf(&quot;*pMyStruct：%d\\n&quot;, sizeof(*pMyStruct));        &#x2F;&#x2F; 16字节 指向我们的内存：myStruct。\nprintf(&quot;pMystruct：%d\\n&quot;, sizeof(pMyStruct));                &#x2F;&#x2F; 4|8字节，指针的内存是固定的\nstrcpy(pMyStruct-&gt;hello, &quot;Hello&quot;);\npMyStruct-&gt;a &#x3D; 50;\nprintf(&quot;pMystruct：%s %d\\n&quot;, pMyStruct-&gt;hello, pMyStruct-&gt;a);\n\nchar name[10];\nprintf(&quot;输入你要的pMyStruct的值：&quot;);\nscanf(&quot;%s&quot;, name);\n&#x2F;&#x2F; 需要注意的是我们不能通过 char name&#123;1，2，3&#125;;来修改，它存在于栈区，我们只能修改&quot;字符串&quot;\nstrcpy(pMyStruct-&gt;hello, name);\n&#x2F;&#x2F; 当然你可以char* name &#x3D; Hello，然后传入进去\nprintf(&quot;pMyStruct：%s %d\\n&quot;, pMyStruct-&gt;hello, pMyStruct-&gt;a);\n\n&#x2F;&#x2F; 如果非要传入&#123;&#125;可以有以下方法\nchar Name[10] &#x3D; &#123; &#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39; &#125;;\n&#x2F;&#x2F; 栈区数组赋值\nfor (int i &#x3D; 0; i &lt; strlen(Name); i++) &#123;        &#x2F;&#x2F; 如果你不知道大小可以采用strlen函数\npMyStruct-&gt;hello[i] &#x3D; Name[i];\n&#125;\nprintf(&quot;pMyStruct：%s %d\\n&quot;, pMyStruct-&gt;hello, pMyStruct-&gt;a);\n\n&#x2F;&#x2F; 如果我们把采用strcpy还可以采用\nchar* pName &#x3D; &quot;ZhangSan&quot;;\nif (pMyStruct &#x3D;&#x3D; NULL) &#123;\nreturn NULL;\n&#125;\nfor (int i &#x3D; 0; i &lt; 9; i++) &#123;\npMyStruct-&gt;hello[i] &#x3D; pName[i];\n&#125;\nprintf(&quot;pMyStruct：%s %d\\n&quot;, pMyStruct-&gt;hello, pMyStruct-&gt;a);\npName &#x3D; &quot;LiSi&quot;;\nfor (pMyStruct &#x3D; pName; pMyStruct &lt; pName + 5; pMyStruct++) &#123;\nprintf(&quot;pMyStruct： %s\\n&quot;, pMyStruct-&gt;hello);\n&#125;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"C语言赋值细节二\"><a href=\"#C语言赋值细节二\" class=\"headerlink\" title=\"C语言赋值细节二\"></a>C语言赋值细节二</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nMyStruct* Test();\n\ntypedef struct MyStruct &#123;\nchar* Hello;\n&#125;MyStruct;\n\nvoid main(void) &#123;\n\nMyStruct myStruct;\nMyStruct* pMyStruct &#x3D; &amp;myStruct;\n\n&#x2F;**\n*        字符串是不动的常量，在内存中是以下的表现：\n*        const char* H &#x3D; &quot;Arvin&quot;\n*        它在全局区是不可更改的，我们通过指针地址将它赋值给pMySruct，说白了就是地址的转移。\n*&#x2F;\nchar* H &#x3D; &quot;Arvin&quot;;\npMyStruct-&gt;Hello &#x3D; H;\n\n&#x2F;**\n*        I是在栈区的数组。\n*        pMyStruct是在Main函数中的所以下面不会出问题。\n*        如果在外部函数中这样，需要讲值传递置堆区。\n*        栈区是先进后出的模型运行的，Main函数先进，所以当Test进入，出去时候将值传给了Main还是可以正常运行的。\n*        此处涉及主调函数、被调函数、函数调用模型有关系。\n*&#x2F;\nchar I[10] &#x3D; &#123; &#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;&#125;;\npMyStruct-&gt;Hello &#x3D; I;\n\nprintf(&quot;%s\\n&quot;, pMyStruct-&gt;Hello);\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h3 id=\"C语言实现界面\"><a href=\"#C语言实现界面\" class=\"headerlink\" title=\"C语言实现界面\"></a>C语言实现界面</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main(void) &#123;\nputs(&quot;\\n&quot;);\nputs(&quot;\\n&quot;);\nputs(&quot;\\t\\t ---------------------------&quot;);\nputs(&quot;\\t\\t|   Leve1:1                 |&quot;);\nputs(&quot;\\t\\t|   Leve1:2                 |&quot;);\nputs(&quot;\\t\\t|   Leve1:3                 |&quot;);\nputs(&quot;\\t\\t|   Leve1:4                 |&quot;);\nputs(&quot;\\t\\t|   Leve1:5                 |&quot;);\nputs(&quot;\\t\\t ---------------------------&quot;);\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<p>Dos窗口的大小为：宽80字符高25字符<br>一个\\t的是8个字符。</p>\n<h3 id=\"puts和printf的区别和putchar的区别\"><a href=\"#puts和printf的区别和putchar的区别\" class=\"headerlink\" title=\"puts和printf的区别和putchar的区别\"></a>puts和printf的区别和putchar的区别</h3><p>printf、pytchar和puts函数均为输出函数。printf函数可以输出各种不同类型的数据，putchar函数只能输出字符数据，而puts函数可输出字符串数据。<br>puts(s)的作用与语句printf(“%s”,s)的作用基本相同，puts函数只能输出字符串，不能输出1数值或进行格式变换，puts函数在输出字符它自带换行。</p>\n<h3 id=\"结构体保存数据\"><a href=\"#结构体保存数据\" class=\"headerlink\" title=\"结构体保存数据\"></a>结构体保存数据</h3><p>C语言没有类的概念，我们做一些属性的时候，只能是往结构体里保存。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Info &#123;\nchar Name[10];\nchar Gender[10];\ndouble Height;\nunsigned short Age;\n&#125;Info;\n\nvoid main(void) &#123;\nInfo info &#x3D; &#123; 0,0,0,0 &#125;;        &#x2F;&#x2F; 初始化，如果字符类型没有初始化可能就直接报错\n&#x2F;&#x2F; 断点调试\n\n&#x2F;* 值指向 info 的数组指针 *&#x2F;\nInfo* pInfo &#x3D; &amp;info;\n\n&#x2F;* 写入数据 *&#x2F;\nprintf(&quot;请输入您的姓名：&quot;);\nscanf(&quot;%s&quot;, pInfo-&gt;Name);\nprintf(&quot;您的姓名是：%s\\n&quot;, pInfo-&gt;Name);\n\nprintf(&quot;请输入你的性别：&quot;);\nscanf(&quot;%s&quot;, pInfo-&gt;Gender);\nprintf(&quot;您的性别为：%s\\n&quot;, pInfo-&gt;Gender);\n\nif ((!strcmp(pInfo-&gt;Gender,&quot;男&quot;)) || (!strcmp(pInfo-&gt;Gender,&quot;男生&quot;))) &#123; &#x2F;&#x2F; 这个函数比较特殊，需要反转一下\nprintf(&quot;请输入您的身高：&quot;);\nscanf(&quot;%lf&quot;,  &amp;pInfo-&gt;Height);                &#x2F;&#x2F; 注意是 LF\nprintf(&quot;您的身高为：%g\\n&quot;, pInfo-&gt;Height);\n\nprintf(&quot;请输入您的年龄：&quot;);\nscanf(&quot;%u&quot;, &amp;pInfo-&gt;Age);\nprintf(&quot;你的年龄为：%u\\n&quot;, pInfo-&gt;Age);\n&#125;\n\nprintf(&quot;\\n&quot;);\nsystem(&quot;pause&quot;);\n&#125;</code></pre>\n<h4 id=\"strcmp-的作用\"><a href=\"#strcmp-的作用\" class=\"headerlink\" title=\"strcmp 的作用\"></a><em>strcmp 的作用</em></h4><p>比较字符串，0代表两个相同，非0代表两个字符串不相同。</p>\n","text":"5.1.0 内存四区模型操作系统把物理硬盘代码 load 到内存。操作系统把C代码分成四个区。操作系统找到Main函数入口执行。 内存四区一个由C&#x2F;C...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-0-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">5.1.0 内存四区模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA\"><span class=\"toc-text\">内存四区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8C%BA%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">全局区详解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%8C%BA%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">栈区详解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%8C%BA%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">堆区详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#strcpy-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">strcpy 函数的作用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-2-%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">5.1.2 指针运算（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">指针与数组练习</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9A%84%E9%97%B4%E6%8E%A5%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">指针的间接赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">指针数组</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5.1.3 结构体基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">结构体初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">结构体变量之间赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84-%E6%A0%88%E5%8C%BA\"><span class=\"toc-text\">结构体静态数组-栈区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%A0%86%E5%8C%BA\"><span class=\"toc-text\">结构体动态数组-堆区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">结构体嵌套数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%8B%E5%80%BC%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">结构体赋值细节</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C%E8%AF%AD%E8%A8%80%E8%B5%8B%E5%80%BC%E7%BB%86%E8%8A%82%E4%BA%8C\"><span class=\"toc-text\">C语言赋值细节二</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">C语言实现界面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#puts%E5%92%8Cprintf%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8Cputchar%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">puts和printf的区别和putchar的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">结构体保存数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#strcmp-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">strcmp 的作用</span></a></li></ol></li></ol></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C语言文件操作","uid":"4bf8b9a001bc016f6215f57ed0fd32d2","slug":"C_2022_3.21.01","date":"2022-03-21T05:20:00.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/C_2022_3.21.01.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0","text":"未完 6.0 文件基本操作对文件的操作我们所要采用指针，C语言创建之初是为了写unix系统，也就是后来的Linux系挺，它对文件是流的操控。需要注意，如果使用完...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C语言指针(上)","uid":"bc8f9b6164f4278e84078fb333015364","slug":"C_2022_3.09.01","date":"2022-03-09T07:20:00.000Z","updated":"2023-11-26T10:38:32.665Z","comments":true,"path":"api/articles/C_2022_3.09.01.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0","text":"5.0.1 外挂原理与指针什么是内存？从硬件形态上来说，内存就是一条形物理设备，从功能上来讲，内存是一个数据仓库，程序在执行前都要被装载到内存中，才能被中央处理...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"程序","slug":"程序","count":29,"path":"api/categories/程序.json"}],"tags":[{"name":"教学文档","slug":"教学文档","count":33,"path":"api/tags/教学文档.json"},{"name":"C语言","slug":"C语言","count":9,"path":"api/tags/C语言.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}