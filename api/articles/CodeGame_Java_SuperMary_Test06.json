{"title":"Java 马里奥类","uid":"060767d5f4be74152fd9d1681be93417","slug":"CodeGame_Java_SuperMary_Test06","date":"2021-11-12T11:28:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Java_SuperMary_Test06.json","keywords":null,"cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.yhipSAzNiVulV4MZu2cVJAHaEH?pid=ImgDet&rs=1","content":"<h4 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.arvin;\n\nimport java.awt.image.BufferedImage;\n\n&#x2F;**\n *  马里奥类\n *&#x2F;\n\n&#x2F;&#x2F; 利用马里奥类实现 Runnadle 接口 重写其中的抽象方法\npublic class Mario implements Runnable &#123;\n\n    &#x2F;&#x2F; 用于表示(存储)横纵坐标\n    private int x, y;\n\n    &#x2F;&#x2F; 用于表示马里奥当前状态\n    private String status;\n\n    &#x2F;&#x2F; 显示当前状态对应的图像\n    private BufferedImage show &#x3D; null;\n\n    &#x2F;&#x2F; 定义一个 BackGround 对象用来获取障碍物信息\n    private BackGround backGround &#x3D; new BackGround();\n\n    &#x2F;&#x2F; 用来实现马里奥动作 线程对象\n    private Thread thread &#x3D; null;\n\n    &#x2F;&#x2F; 马里奥的移动速度\n    private int xSpeed;\n\n    &#x2F;&#x2F; 马里奥的跳跃速度\n    private int ySpeed;\n\n    &#x2F;&#x2F; 定义一个索引 取得马里奥的运动图像\n    private int indexOf;\n\n    &#x2F;&#x2F; 表示马里奥上升的时间\n    private int upTime &#x3D; 0;\n\n    &#x2F;&#x2F; 判断马里奥是否走到了城堡门口\n    private boolean isOK;\n\n    &#x2F;&#x2F; 判断马里奥是否死亡\n    private boolean isDeath &#x3D; false;\n\n    &#x2F;&#x2F; 积分系统 表示分数\n    private int score &#x3D; 0;\n\n    &#x2F;&#x2F; 定义构造函数\n    public Mario()&#123;\n\n    &#125;\n\n    public Mario(int x, int y)&#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n        show &#x3D; StaticValue.Stand_Right;     &#x2F;&#x2F; 初始化 show\n        this.status &#x3D; &quot;stand--Right&quot;;     &#x2F;&#x2F; 用于表示马里奥当前的状态\n        thread &#x3D; new Thread(this);    &#x2F;&#x2F; 初始化线程\n        thread.start();                     &#x2F;&#x2F; 启动线程 调用 start 方法\n\n    &#125;\n\n    &#x2F;&#x2F; 马里奥死亡方法\n    public void death() &#123;\n        isDeath &#x3D; true;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥向左移动\n    public void leftMove () &#123;\n\n        &#x2F;&#x2F; 改变移动速度\n        xSpeed &#x3D; -5;\n\n        &#x2F;&#x2F; 判断马里奥是否碰到了旗子 马里奥就应该无法移动\n        if (backGround.isReach()) &#123;\n            xSpeed &#x3D; 0;\n        &#125;\n\n        &#x2F;&#x2F; 判断马里奥是否处于空中\n        if (status.indexOf(&quot;jump&quot;) !&#x3D; -1)&#123;\n            status &#x3D; &quot;jump--left&quot;;\n        &#125;else&#123;\n            status &#x3D; &quot;move--left&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥向右移动\n    public void rightMove () &#123;\n        xSpeed &#x3D; 5;\n\n        &#x2F;&#x2F; 判断马里奥是否碰到了旗子 马里奥就应该无法移动\n        if (backGround.isReach()) &#123;\n            xSpeed &#x3D; 0;\n        &#125;\n\n        if (status.indexOf(&quot;jump&quot;) !&#x3D; -1)&#123;\n            status &#x3D; &quot;jump--right&quot;;\n        &#125;else&#123;\n            status &#x3D; &quot;move--right&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥向左停止\n    public void leftStop () &#123;\n        xSpeed &#x3D; 0;\n        if (status.indexOf(&quot;jump&quot;) !&#x3D; -1)&#123;\n            status &#x3D; &quot;jump--left&quot;;\n        &#125;else&#123;\n            status &#x3D; &quot;stop--left&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥向右停止\n    public void rightStop () &#123;\n        xSpeed &#x3D; 0;\n        if (status.indexOf(&quot;jump&quot;) !&#x3D; -1)&#123;\n            status &#x3D; &quot;jump--right&quot;;\n        &#125;else&#123;\n            status &#x3D; &quot;stop--right&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥跳跃\n    public void jump () &#123;\n        if (status.indexOf(&quot;jump&quot;) &#x3D;&#x3D; -1)&#123;  &#x2F;&#x2F; 判断马里奥是否是跳跃状态(-1 表示不是)\n            if (status.indexOf(&quot;left&quot;) !&#x3D; -1) &#123;  &#x2F;&#x2F; 判断马里奥此时的方向(-1 表示向左)\n                status &#x3D; &quot;jump--left&quot;;\n            &#125;else&#123;\n                status &#x3D; &quot;jump--right&quot;;\n            &#125;\n            ySpeed &#x3D; -10;\n            upTime &#x3D; 7;\n        &#125;\n\n        &#x2F;&#x2F; 判断马里奥是否碰到了旗子 马里奥就应该无法移动\n        if (backGround.isReach()) &#123;\n            ySpeed &#x3D; 0;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 马里奥下落\n    public void fall () &#123;\n        if (status.indexOf(&quot;left&quot;) !&#x3D; -1)&#123;\n            status &#x3D; &quot;jump--left&quot;;\n        &#125;else&#123;\n            status &#x3D; &quot;jump--right&quot;;\n        &#125;\n        ySpeed &#x3D; 10;\n    &#125;\n\n    &#x2F;&#x2F; 重写 Runnable 的抽象方法\n    @Override\n    public void run() &#123;\n\n        &#x2F;&#x2F; while 死循环\n        while (true) &#123;\n\n            &#x2F;&#x2F; 判断马里奥是否处于障碍物上\n            boolean onObstacle &#x3D; false;\n\n            &#x2F;&#x2F; 判断是否可以往右走\n            boolean canRight &#x3D; true;\n\n            &#x2F;&#x2F; 判断是否可以往左走\n            boolean canLeft &#x3D; true;\n\n            &#x2F;&#x2F; 判断马里奥是否到达旗杆位置 (游戏结束)\n            if (backGround.isFlag() &amp;&amp; this.x &gt;&#x3D; 500)&#123;\n                this.backGround.setReach(true);\n                if(this.backGround.isBase()) &#123; &#x2F;&#x2F; 判断旗子是否下落完成\n                    status &#x3D; &quot;move--right&quot;;\n                    if (x &lt; 690) &#123; &#x2F;&#x2F; 判断马里奥是否移动到了中间\n                        x +&#x3D; 5;\n                    &#125;else&#123;\n                        isOK &#x3D; true;\n                    &#125;\n                &#125;else&#123;\n                    if (y &lt; 395) &#123;\n                        xSpeed &#x3D; 0;\n                        this.y +&#x3D; 5;\n                        status &#x3D; &quot;jump--right&quot;;\n                    &#125;\n\n                    if (y &gt; 395) &#123;\n                        this.y &#x3D; 395;\n                        status &#x3D; &quot;stop--right&quot;;\n                    &#125;\n                &#125;\n\n            &#125;else&#123;\n\n                &#x2F;&#x2F; 遍历当前场景里所有的障碍物\n                for (int i &#x3D; 0; i &lt;backGround.getObstacleList().size(); i++) &#123;\n                    Obstacle obstacle &#x3D; backGround.getObstacleList().get(i); &#x2F;&#x2F; 临时变量存储当前场景障碍物信息\n                    if (obstacle.getY() &#x3D;&#x3D; this.y + 25 &amp;&amp; (obstacle.getX() &gt; this.x -30 &amp;&amp; obstacle.getX() &lt; this.x +25))&#123; &#x2F;&#x2F; 判断马里奥是否处于障碍物上\n                        onObstacle &#x3D; true;\n                    &#125;\n\n                    &#x2F;&#x2F; 判断是否跳起来顶到砖块 (碰撞检测)\n                    if ((obstacle.getY() &gt;&#x3D; this.y -30 &amp;&amp; obstacle.getY() &lt;&#x3D; this.y -20) &amp;&amp; (obstacle.getX() &gt; this.x -30 &amp;&amp; obstacle.getX() &lt; this.x + 25))&#123;\n                        if (obstacle.getType() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 检测障碍物类型 (0 可破坏砖块)\n                            backGround.getObstacleList().remove(obstacle);\n                            score +&#x3D; 1; &#x2F;&#x2F; 积分+1\n                        &#125;\n                        upTime &#x3D; 0; &#x2F;&#x2F; 行为反馈 顶到砖块立刻下落\n                    &#125;\n\n                    &#x2F;&#x2F; 判断是否可以往右走 (碰撞检测)\n                    if (obstacle.getX() &#x3D;&#x3D; this.x + 25 &amp;&amp; (obstacle.getY() &gt; this.y -30 &amp;&amp; obstacle.getY() &lt; this.y +25))&#123;\n                        canRight &#x3D; false;\n                    &#125;\n\n                    &#x2F;&#x2F; 判断是否可以往左走 (碰撞检测)\n                    if (obstacle.getX() &#x3D;&#x3D; this.x - 30 &amp;&amp; (obstacle.getY() &gt; this.y - 30 &amp;&amp; obstacle.getY() &lt; this.y + 25)) &#123;\n                        canLeft &#x3D; false;\n                    &#125;\n                &#125;\n\n                &#x2F;&#x2F; 判断马里奥是否碰到敌人死亡或者踩死敌人\n                for (int i &#x3D; 0; i &lt; backGround.getEnemyList().size(); i++) &#123; &#x2F;&#x2F; 遍历每一个敌人\n                    Enemy enemy &#x3D; backGround.getEnemyList().get(i); &#x2F;&#x2F; enemy 存储当前的敌人\n\n                    &#x2F;&#x2F; 判断马里奥是否位于敌人头上 与判断障碍物是一样的\n                    if (enemy.getY() &#x3D;&#x3D; this.y + 20 &amp;&amp; (enemy.getX() -25 &lt;&#x3D; this.x &amp;&amp; enemy.getX() +35 &gt;&#x3D; this.x)) &#123;\n                        &#x2F;&#x2F; 判断是蘑菇敌人还是食人花敌人 蘑菇敌人才可以踩死\n                        if (enemy.getType() &#x3D;&#x3D; 1) &#123;\n                            enemy.death();  &#x2F;&#x2F; 调用蘑菇敌人的死亡方法\n                            score +&#x3D; 2;\n\n                            &#x2F;&#x2F; 让马里奥上升一小段\n                            upTime &#x3D; 3;\n                            ySpeed &#x3D; -10;\n                        &#125;else if (enemy.getType()&#x3D;&#x3D; 2)&#123; &#x2F;&#x2F; 食人花敌人情况\n                            &#x2F;&#x2F; 马里奥死亡\n                            death();\n                        &#125;\n                    &#125;\n                    &#x2F;&#x2F; 判断马里奥是否碰到敌人 碰到死亡\n                    if ((enemy.getX() + 35 &gt; this.x &amp;&amp; enemy.getX() - 25 &lt; this.x) &amp;&amp; (enemy.getY() + 35 &gt;this.y &amp;&amp; enemy.getY() -20 &lt; this.y)) &#123;\n                        &#x2F;&#x2F; 马里奥死亡\n                        death();\n                    &#125;\n                &#125;\n\n                &#x2F;&#x2F; 进行马里奥跳跃\n                if (onObstacle &amp;&amp; upTime &#x3D;&#x3D; 0)&#123;\n                    if (status.indexOf(&quot;left&quot;) !&#x3D; -1)&#123;\n                        if (xSpeed !&#x3D; 0)&#123;\n                            status &#x3D; &quot;move--left&quot;;\n                        &#125;else&#123;\n                            status &#x3D; &quot;stop--left&quot;;\n                        &#125;\n                    &#125;else&#123;\n                        if (xSpeed !&#x3D; 0)&#123;\n                            status &#x3D; &quot;move--right&quot;;\n                        &#125;else&#123;\n                            status &#x3D; &quot;stop--right&quot;;\n                        &#125;\n                    &#125;\n                &#125;else&#123;\n                    if (upTime !&#x3D; 0)&#123;\n                        upTime--;   &#x2F;&#x2F; 一直自检\n                    &#125;else&#123;\n                        fall(); &#x2F;&#x2F; 让他下落\n                    &#125;\n                    y +&#x3D; ySpeed; &#x2F;&#x2F; 改变坐标值\n                &#125;\n\n\n                &#x2F;&#x2F; 判断马里奥是否在运动\n                if (canLeft &amp;&amp; xSpeed &lt; 0 || canRight &amp;&amp; xSpeed &gt; 0) &#123;\n                    x +&#x3D; xSpeed;\n\n                    &#x2F;&#x2F; 判断马里奥是否到了最左边\n                    if (x &lt; 0)&#123;\n                        x &#x3D; 0;\n                    &#125;\n                &#125;\n\n                &#x2F;&#x2F; 判断当前是否是移动状态\n                if (status.contains(&quot;move&quot;)) &#123;\n                    indexOf &#x3D; indexOf &#x3D;&#x3D; 0 ? 1 : 0;\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向左移动\n                if (&quot;move--left&quot;.equals(status)) &#123;\n                    show &#x3D; StaticValue.Run_Left.get(indexOf);\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向右移动\n                if (&quot;move--right&quot;.equals(status)) &#123;\n                    show &#x3D; StaticValue.Run_Right.get(indexOf);\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向左停止\n                if (&quot;stop--left&quot;.equals(status)) &#123;\n                    show &#x3D; StaticValue.Stand_Left;\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向右停止\n                if (&quot;stop-right&quot;.equals(status)) &#123;\n                    show &#x3D; StaticValue.Stand_Right;\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向左跳跃\n                if (&quot;jump--left&quot;.equals(status))&#123;\n                    show &#x3D; StaticValue.Jump_Left;\n                &#125;\n\n                &#x2F;&#x2F; 判断是否向右跳跃\n                if (&quot;jump--right&quot;.equals(status))&#123;\n                    show &#x3D; StaticValue.Jump_Right;\n                &#125;\n\n                &#x2F;&#x2F; 线程休眠 50 毫秒\n                try &#123;\n                    Thread.sleep(50);\n                &#125; catch (InterruptedException exception) &#123;\n                    exception.printStackTrace();\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n\n\n    &#x2F;&#x2F; 生成 x y BufferedImage 的 set 和 get 方法\n    public int getX() &#123;\n        return x;\n    &#125;\n\n    public void setX(int x) &#123;\n        this.x &#x3D; x;\n    &#125;\n\n    public int getY() &#123;\n        return y;\n    &#125;\n\n    public void setY(int y) &#123;\n        this.y &#x3D; y;\n    &#125;\n\n    public BufferedImage getShow() &#123;\n        return show;\n    &#125;\n\n    public void setShow(BufferedImage show) &#123;\n        this.show &#x3D; show;\n    &#125;\n\n    &#x2F;&#x2F; 生成 backGround 的 set 方法\n    public void setBackGround(BackGround backGround) &#123;\n        this.backGround &#x3D; backGround;\n    &#125;\n\n    &#x2F;&#x2F; 生成 判断马里奥是否到城堡门口的 Get 方法\n    public boolean isOK() &#123;\n        return isOK;\n    &#125;\n\n    &#x2F;&#x2F; 生成 isDeath 的 Get 方法\n    public boolean isDeath() &#123;\n        return isDeath;\n    &#125;\n\n    &#x2F;&#x2F; 生成分数的 Get 方法\n    public int getScore() &#123;\n        return score;\n    &#125;\n&#125;\n</code></pre>","text":"代码演示package com.arvin; import java.awt.image.BufferedImage; &#x2F;** * 马里奥类 *&#x...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">代码演示</span></a></li></ol>","author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java 敌人类","uid":"d6ed492f35699105c54e7daa2c4807c0","slug":"CodeGame_Java_SuperMary_Test07","date":"2021-11-14T10:48:52.000Z","updated":"2023-11-26T10:38:32.669Z","comments":true,"path":"api/articles/CodeGame_Java_SuperMary_Test07.json","keywords":null,"cover":"https://pic2.zhimg.com/v2-957d2a1fac8856452f3ce0aac00427d9_b.jpg","text":"代码演示package com.arvin; import java.awt.image.BufferedImage; &#x2F;** * 敌人类 *&#x2...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"CodeGame","slug":"CodeGame","count":9,"path":"api/categories/CodeGame.json"}],"tags":[{"name":"程序","slug":"程序","count":11,"path":"api/tags/程序.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【無憂樹洞】但行好事，莫问前程「暴力兔」","uid":"038212bdfa28833817e00c513951e73b","slug":"eqistle.2021.11.08.01","date":"2021-11-08T10:08:38.000Z","updated":"2023-11-26T10:38:32.673Z","comments":true,"path":"api/articles/eqistle.2021.11.08.01.json","keywords":null,"cover":"https://z3.ax1x.com/2021/11/08/IGGoLt.jpg","text":"您好，我是陆弦，我又写信了。 这篇文章是2020年5月23日写的，今天是2020年7月17日。祝朋友们，内心平和柔软，外表无坚不摧。 但行好事 莫问前程 原创 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"书信","slug":"书信","count":9,"path":"api/categories/书信.json"}],"tags":[{"name":"暴力兔书信","slug":"暴力兔书信","count":1,"path":"api/tags/暴力兔书信.json"}],"author":{"name":"Arvin","slug":"blog-author","avatar":"/imgs/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}